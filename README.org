# Created 2020-01-01 Wed 12:59
#+OPTIONS: html-postamble:nil toc:nil d:nil num:t :results nil
#+TITLE: A Life Configuring Emacs
#+DATE: 2018-07-25
#+AUTHOR: Musa Al-hassy
#+export_file_name: README.org

#+html: <p align="center"> <img src="emacs-logo.png" width=150 height=150/> </p> <p align="center"> <a href="https://www.gnu.org/software/emacs/"> <img src="https://img.shields.io/badge/GNU%20Emacs-26.1-b48ead.svg?style=plastic"/></a> <a href="https://orgmode.org/"><img src="https://img.shields.io/badge/org--mode-9.3.1-489a9f.svg?style=plastic"/></a> </p> <p align="center"> <img src="emacs-birthday-present.png" width=200 height=250/> </p>

I enjoy reading others' /literate/ configuration files and
incorporating what I learn into my own. The result is a
sufficiently well-documented and accessible read that yields
a stylish and functional system (‚Ä¢ÃÄ·¥ó‚Ä¢ÃÅ)Ÿà

This ~README.org~ has been automatically generated from my
configuration and its contents below are accessible
in (outdated) blog format, with /colour/, or as colourful
PDF, [[https://alhassy.github.io/init/][here]]. Enjoy
:smile:

#+description: My Emacs Initialisation File, Written in Org-mode.
#+startup: indent lognoteclock-out
#+property: header-args :tangle init.el :comments link :results none

#+sourcefile: https://github.com/alhassy/emacs.d/blob/master/init.org
#+image: ../assets/img/emacs_logo.png
#+categories: Emacs Lisp

#+begin_src emacs-lisp :tangle no :exports results :wrap "export html" :results replace
(concat
"<p align=\"center\">
        <a href=\"https://www.gnu.org/software/emacs/\">
        <img src=\"https://img.shields.io/badge/GNU%20Emacs-" emacs-version "-b48ead.svg?style=plastic\"/></a>
        <a href=\"https://orgmode.org/\"><img src=\"https://img.shields.io/badge/org--mode-" org-version "-489a9f.svg?style=plastic\"/></a>
</p>")
#+end_src

#+html: <p align="center">
#+begin_center
*Abstract*
#+end_center
#+html: </p>

Herein I document the configurations I utilise with [[https://gnu.org/s/emacs][Emacs]].

As a [[https://www.offerzen.com/blog/literate-programming-empower-your-writing-with-emacs-org-mode][literate program]] file with [[http://orgmode.org/][Org-mode]], I am ensured optimal navigation
through my ever growing configuration files, ease of usability and reference
for peers, and, most importantly, better maintainability for myself!

Dear reader, when encountering a foregin command ~X~ I encourage you to execute
~(describe-symbol 'X)~, or press ~C-h o~ with the cursor on ~X~.  An elementary Elisp
Cheat Sheet can be found [[https://github.com/alhassy/ElispCheatSheet][here]] and here is a 2-page 3-column [[https://github.com/alhassy/emacs.d/blob/master/CheatSheet.pdf][Emacs Cheat Sheet]] of
the bindings in ~‚Äúthis‚Äù~ configuration.
- ~C-h o~ ‚áí *What's this thing?*
- ~C-h e~ ‚áí *What'd /Emacs/ do?*
- ~C-h l~ ‚áí *What'd /I/ do?*
- ‚ÄúI accidentally hit a key, which one and what did it do!?‚Äù ‚áí ~C-h e~ and ~C-h l~,
  then use ~C-h o~ to get more details on the action.
  ;-)

Finally, ~C-h d~ asks nicely what ‚Äòd‚Äôocumentation you're interested in.
After providing a few keywords, the =apropos= tool yields possible functions
and variables that may accomplish my goal.

* Table of Contents                                        :Github:TOC_4_org:
- [[Why Emacs?][Why Emacs?]]
- [[Booting Up][Booting Up]]
  - [[=~/.emacs= vs. =init.org=][=~/.emacs= vs. =init.org=]]
    - [[/Adventure time!/ ‚ÄúHoney, where's my init?‚Äù][/Adventure time!/ ‚ÄúHoney, where's my init?‚Äù]]
    - [[/Adventure time!/ Using Emacs' Easy Customisation Interface][/Adventure time!/ Using Emacs' Easy Customisation Interface]]
    - [[Support for ‚ÄòCustom‚Äô][Support for ‚ÄòCustom‚Äô]]
  - [[=use-package= ---The start of =init.el=][=use-package= ---The start of =init.el=]]
  - [[=README= ---From =init.org= to =init.el=][=README= ---From =init.org= to =init.el=]]
  - [[Installing Emacs packages directly from source][Installing Emacs packages directly from source]]
  - [[=magit= ---Emacs' porcelain interface to git][=magit= ---Emacs' porcelain interface to git]]
  - [[Syncing to the System's =$PATH=][Syncing to the System's =$PATH=]]
  - [[Installing OS packages, and automatically keeping my system up to data, from within Emacs][Installing OS packages, and automatically keeping my system up to data, from within Emacs]]
  - [[‚ÄúBeing at the Helm‚Äù ---Completion & Narrowing Framework][‚ÄúBeing at the Helm‚Äù ---Completion & Narrowing Framework]]
  - [[Having a workspace manager in Emacs][Having a workspace manager in Emacs]]
  - [[Excellent PDF Viewer][Excellent PDF Viewer]]
  - [[Who am I? ---Using Gnus for Gmail][Who am I? ---Using Gnus for Gmail]]
    - [[Prettifications][Prettifications]]
    - [[Super Terse Tutorial][Super Terse Tutorial]]
    - [[Auto-completing mail addresses][Auto-completing mail addresses]]
    - [[Feeds to Blogs][Feeds to Blogs]]
  - [[Hydra: Supply a prefix only once][Hydra: Supply a prefix only once]]
  - [[Quickly pop-up a terminal, run a command, close it ---and zsh][Quickly pop-up a terminal, run a command, close it ---and zsh]]
  - [[Restarting Emacs ---Keeping buffers open across sessions?][Restarting Emacs ---Keeping buffers open across sessions?]]
  - [[Automatic Backups][Automatic Backups]]
  - [[Editor Documentation with Contextual Information][Editor Documentation with Contextual Information]]
- [[Cosmetics][Cosmetics]]
  - [[Startup message: Emacs & Org versions][Startup message: Emacs & Org versions]]
  - [[My to-do list: The initial buffer when Emacs opens up][My to-do list: The initial buffer when Emacs opens up]]
  - [[Exquisite Themes][Exquisite Themes]]
  - [[A sleek & informative mode line][A sleek & informative mode line]]
  - [[Never lose the cursor][Never lose the cursor]]
  - [[Dimming Unused Windows][Dimming Unused Windows]]
  - [[Buffer names are necessarily injective][Buffer names are necessarily injective]]
  - [[Flashing when something goes wrong ---no blinking][Flashing when something goes wrong ---no blinking]]
  - [[Hiding Scrollbar, tool bar, and menu][Hiding Scrollbar, tool bar, and menu]]
  - [[Highlight & complete parenthesis pair when cursor is near ;-)][Highlight & complete parenthesis pair when cursor is near ;-)]]
  - [[Neotree: Directory Tree Listing][Neotree: Directory Tree Listing]]
  - [[Tabs][Tabs]]
  - [[Window resizing using the golden ratio][Window resizing using the golden ratio]]
  - [[Persistent Scratch Buffer][Persistent Scratch Buffer]]
- [[Prose][Prose]]
  - [[Fill-mode ---Word Wrapping][Fill-mode ---Word Wrapping]]
  - [[Word Completion][Word Completion]]
  - [[Fix spelling as you type ---thesaurus & dictionary too!][Fix spelling as you type ---thesaurus & dictionary too!]]
  - [[Touch Typing][Touch Typing]]
  - [[Using a Grammar & Style Checker][Using a Grammar & Style Checker]]
  - [[Lightweight Prose Proofchecking][Lightweight Prose Proofchecking]]
  - [[Placeholder Text ---For Learning & Experimenting][Placeholder Text ---For Learning & Experimenting]]
  - [[Some text to make us smile][Some text to make us smile]]
  - [[Unicode Input via Agda Input][Unicode Input via Agda Input]]
  - [[Increase/decrease text size][Increase/decrease text size]]
  - [[Moving Text Around][Moving Text Around]]
  - [[Enabling CamelCase Aware Editing Operations][Enabling CamelCase Aware Editing Operations]]
  - [[Mouse Editing Support][Mouse Editing Support]]
  - [[Delete Selection Mode][Delete Selection Mode]]
  - [[~M-n,p~: Word-at-Point Navigation][~M-n,p~: Word-at-Point Navigation]]
  - [[Letter-based Navigation][Letter-based Navigation]]
  - [[~C-c e n,p~: Taking a tour of one's edits][~C-c e n,p~: Taking a tour of one's edits]]
- [[Org-Mode Administrivia][Org-Mode Administrivia]]
  - [[Executing code from ~src~ blocks][Executing code from ~src~ blocks]]
  - [[High Speed Literate Programming][High Speed Literate Programming]]
    - [[Manipulating Sections][Manipulating Sections]]
    - [[Seamless Navigation Between Source Blocks][Seamless Navigation Between Source Blocks]]
    - [[Modifying ~<return>~][Modifying ~<return>~]]
    - [[~C-a,e,k~ and Yanking of sections][~C-a,e,k~ and Yanking of sections]]
  - [[Hiding Emphasise Markers & Inlining Images][Hiding Emphasise Markers & Inlining Images]]
  - [[Org-Emphasise for Parts of Words][Org-Emphasise for Parts of Words]]
  - [[Show off-screen heading at the top of the window][Show off-screen heading at the top of the window]]
  - [[Jumping without hassle][Jumping without hassle]]
  - [[Folding within a subtree][Folding within a subtree]]
  - [[Making Block Delimiters Less Intrusive][Making Block Delimiters Less Intrusive]]
- [[Org-Mode ‚áí PDF & HTML][Org-Mode ‚áí PDF & HTML]]
  - [[Working with Citations][Working with Citations]]
  - [[Coloured LaTeX using Minted][Coloured LaTeX using Minted]]
  - [[Ensuring Useful HTML Anchors][Ensuring Useful HTML Anchors]]
  - [[HTML ‚ÄúFolded Drawers‚Äù][HTML ‚ÄúFolded Drawers‚Äù]]
  - [[Reveal.JS -- The HTML Presentation Framework][Reveal.JS -- The HTML Presentation Framework]]
- [[Life within Org-mode][Life within Org-mode]]
  - [[Using Org-Mode as a Day Planner][Using Org-Mode as a Day Planner]]
    - [[Capturing ideas & notes without interrupting the current workflow][Capturing ideas & notes without interrupting the current workflow]]
    - [[Step 1: When new tasks come up][Step 1: When new tasks come up]]
    - [[Step 2: Filing your tasks][Step 2: Filing your tasks]]
    - [[Step 3: Quickly review the upcoming week][Step 3: Quickly review the upcoming week]]
    - [[Step 4: Getting ready for the day][Step 4: Getting ready for the day]]
    - [[Step 5: Doing the work][Step 5: Doing the work]]
    - [[Step 6: Moving a task toward completion][Step 6: Moving a task toward completion]]
    - [[Step 7: Archiving Tasks][Step 7: Archiving Tasks]]
  - [[Super Agenda][Super Agenda]]
  - [[Automating Pomodoro ---‚ÄúCommit for only 25 minutes!‚Äù][Automating Pomodoro ---‚ÄúCommit for only 25 minutes!‚Äù]]
  - [[Journaling][Journaling]]
  - [[Workflow States][Workflow States]]
  - [[Clocking Work Time][Clocking Work Time]]
    - [[Finding tasks to clock in][Finding tasks to clock in]]
    - [[Estimates versus actual time][Estimates versus actual time]]
- [[Programming][Programming]]
  - [[Highlight defined Lisp symbols][Highlight defined Lisp symbols]]
  - [[Eldoc for Lisp and Haskell][Eldoc for Lisp and Haskell]]
  - [[Jumping to definitions & references][Jumping to definitions & references]]
  - [[Aggressive Indentation][Aggressive Indentation]]
  - [[What's changed & who's to blame?][What's changed & who's to blame?]]
  - [[Highlighting TODO-s & Showing them in Magit][Highlighting TODO-s & Showing them in Magit]]
  - [[On the fly syntax checking][On the fly syntax checking]]
  - [[Coding with a Fruit Salad: Semantic Highlighting][Coding with a Fruit Salad: Semantic Highlighting]]
  - [[Text Folding with Origami-mode][Text Folding with Origami-mode]]
  - [[Jump between windows using Cmd+Arrow & between recent buffers with Meta-Tab][Jump between windows using Cmd+Arrow & between recent buffers with Meta-Tab]]
  - [[Snippets ---Template Expansion][Snippets ---Template Expansion]]
    - [[Org-mode Templates ---A reason I ‚Äúgenerate‚Äù templates ;)][Org-mode Templates ---A reason I ‚Äúgenerate‚Äù templates ;)]]
    - [[Elisp Templates][Elisp Templates]]
    - [[Equational Templates][Equational Templates]]
    - [[Re-Enabling Templates][Re-Enabling Templates]]
- [[Helpful Utilities & Shortcuts][Helpful Utilities & Shortcuts]]
  - [[Documentation Pop-Ups][Documentation Pop-Ups]]
  - [[Emacs keybindings for my browser][Emacs keybindings for my browser]]
  - [[Using Emacs in any text area on my OS][Using Emacs in any text area on my OS]]
  - [[Reload buffer with ~f5~][Reload buffer with ~f5~]]
  - [[Kill to start of line][Kill to start of line]]
  - [[Killing buffers & windows: ~C-x k~ has a family][Killing buffers & windows: ~C-x k~ has a family]]
  - [[Switching from 2 horizontal windows to 2 vertical windows][Switching from 2 horizontal windows to 2 vertical windows]]
  - [[Obtaining Values of ~#+KEYWORD~ Annotations][Obtaining Values of ~#+KEYWORD~ Annotations]]
  - [[Publishing articles to my personal blog][Publishing articles to my personal blog]]
- [[Conclusion ---Why Configuration Files Should be Literate][Conclusion ---Why Configuration Files Should be Literate]]

* Why Emacs?
/Emacs is a flexible platform for developing end-user applications/ --unfortunately it is generally perceived as
merely a text editor. Some people use it specifically for one or two applications.

For example, [[https://www.youtube.com/watch?v=FtieBc3KptU][writers]] use it as an interface for Org-mode and others use it as an interface for version
control with Magit. [[https://orgmode.org/index.html#sec-4][Org]] is an organisation tool that can be used for typesetting which subsumes LaTeX, generating many different
formats --html, latex, pdf, etc-- from a single source, keeping track of [[https://orgmode.org/worg/org-tutorials/index.html#orgff7b885][schedules]] & task management, blogging, habit tracking, personal information management tool, and [[http://orgmode.org/worg/org-contrib/][much more]].
Moreover, its syntax is so [[https://karl-voit.at/2017/09/23/orgmode-as-markup-only/][natural]] that most people use it without even knowing!
For me, Org allows me to do literate programming: I can program and document at the same time,
with no need to seperate the two tasks and with the ability to generate multiple formats and files from a single file.

#+begin_quote
If you are a professional writer‚Ä¶Emacs outshines all other editing software
in approximately the same way that the noonday sun does the stars.
It is not just bigger and brighter; it simply makes everything else vanish.
‚Äî[[http://project.cyberpunk.ru/lib/in_the_beginning_was_the_command_line/][Neal Stephenson]], /In the beginning was the command line/
#+end_quote

Of course Emacs comes with the basic features of a text editor, but it is much more;
for example, it comes with a powerful notion of ‚Äòundo‚Äô: Basic text editors have a single stream of undo,
yet in Emacs, we have a tree --when we undo and make new edits, we branch off in our editing stream
as if our text was being version controlled as we type! --We can even switch between such branches!

#+begin_src emacs-lisp :tangle no :noweb-ref undo-tree-setup
;; Allow tree-semantics for undo operations.
(use-package undo-tree
  :diminish                       ;; Don't show an icon in the modeline
  :config
    ;; Always have it on
    (global-undo-tree-mode)

    ;; Each node in the undo tree should have a timestamp.
    (setq undo-tree-visualizer-timestamps t)

    ;; Show a diff window displaying changes between undo nodes.
    (setq undo-tree-visualizer-diff t))

;; Execute (undo-tree-visualize) then navigate along the tree to witness
;; changes being made to your file live!
#+end_src
( The above snippet has a ~noweb-ref~: It is presented here in a natural
position, but is only executable once ~use-package~ is setup and so it
is weaved there! We can /present/ code in any order and /tangle/ it to
the order the compilers need it to be! )

/Emacs is an extensible editor: You can make it into the editor of your dreams!/
You can make it suited to your personal needs.
If there's a feature you would like, a behaviour your desire, you can simply code that into Emacs with
a bit of Lisp. As a programming language enthusiast, for me Emacs is my default Lisp interpreter
and a customisable IDE that I use for other programming languages
--such as C, Haskell, Agda, Lisp, and Prolog.
Moreover, being a Lisp interpreter, we can alter the look and feel of Emacs live, without having
to restart it --e.g., press ~C-x C-e~ after the final parenthesis of ~(scroll-bar-mode 0)~
to run the code that removes the scroll-bar.

#+begin_quote
/I use Emacs every day. I rarely notice it. But when I do, it usually brings me joy./
‚îÄ[[https://so.nwalsh.com/2019/03/01/emacs][Norman Walsh]]
#+end_quote

I have used Emacs as an interface for developing [[https://github.com/alhassy/CheatSheet#cheatsheet-examples][cheat sheets]], for making my
blog, and as an application for ‚Äòinteractively learning C‚Äô. If anything Emacs is
more like an OS than just a text editor --‚Äúliving within Emacs‚Äù provides an
abstraction over whatever operating system my machine has: [[https://www.fugue.co/blog/2015-11-11-guide-to-emacs.html][It's so easy to take
everything with me.]] Moreover, the desire to mould Emacs to my needs has made me
a better programmer: I am now a more literate programmer and, due to Elisp's
documentation-oriented nature, I actually take the time and effort to make
meaningful documentation --even when the project is private and will likely only
be seen by me.

#+begin_quote
/Seeing Emacs as an editor is like seeing a car as a seating-accommodation./ -- [[https://karl-voit.at/2015/10/23/Emacs-is-not-just-an-editor/][Karl Voit]]
#+end_quote

Possibly interesting reads:
- [[https://sachachua.com/blog/series/a-visual-guide-to-emacs/][How to Learn Emacs: A Hand-drawn One-pager for Beginners / A visual tutorial]]
- [[http://emacsrocks.com/][Video Series on Why Emacs Rocks]] ---catch the enthusiasm!
- [[http://ehneilsen.net/notebook/orgExamples/org-examples.html#sec-18][Emacs org-mode examples and cookbook]]
- [[https://m00natic.github.io/emacs/emacs-wiki.html][An Opinionated Emacs guide for newbies and beyond]]
- [[https://tuhdo.github.io/emacs-tutor.html][Emacs Mini-Manual, Part I of III]]
- [[https://github.com/erikriverson/org-mode-R-tutorial/blob/master/org-mode-R-tutorial.org][Org and R Programming]] ---a tutorial on literate programming, e.g., evaluating code within ~src~ bloc.
- Reference cards for [[https://www.gnu.org/software/emacs/refcards/pdf/refcard.pdf][GNU Emacs]], [[https://www.gnu.org/software/emacs/refcards/pdf/orgcard.pdf][Org-mode]], and [[https://github.com/alhassy/ElispCheatSheet/blob/master/CheatSheet.pdf][Elisp]].
- [[https://www.reddit.com/r/emacs/comments/6fytr5/when_did_you_start_using_emacs/][‚ÄúWhen did you start using Emacs‚Äù discussion on Reddit]]
- [[https://david.rothlis.net/emacs/howtolearn.html][‚ÄúHow to Learn Emacs‚Äù]]
- [[https://orgmode.org/index.html#sec-4][The Org-mode Reference Manual]] or [[https://orgmode.org/worg/][Worg: Community-Written Docs]] which includes a [[https://orgmode.org/worg/org-tutorials/index.html][meta-tutorial]].
- [[https://github.com/emacs-tw/awesome-emacs][Awesome Emacs]]: A community driven list of useful Emacs packages, libraries and others.
- [[https://github.com/caisah/emacs.dz][A list of people's nice emacs config files]]
- [[http://emacslife.com/how-to-read-emacs-lisp.html][Read Lisp, Tweak Emacs: How to read Emacs Lisp so that you can customize Emacs]]
- [[https://practicaltypography.com/why-racket-why-lisp.html][Why Racket? Why Lisp?]]

---If eye-candy, a sleek and beautiful GUI, would entice you then consider starting with [[http://spacemacs.org/][spacemacs]].
   Here's a helpful [[https://www.youtube.com/watch?v=hCNOB5jjtmc][installation video]], after which you may want to watch
   [[https://www.youtube.com/watch?v=PVsSOmUB7ic][Org-mode in Spacemacs]] tutorial---

Remember: Emacs is a flexible platform for developing end-user applications; e.g., this configuration file
is at its core an Emacs Lisp program that yields the editor of my dreams
--it encourages me to grow and to be creative, and I hope the same for all who use it;
moreover, it reflects my personality such as what I value and what I neglect in my workflow.

#+begin_quote
I‚Äôm stunned that you, as a professional software engineer, would eschew inferior
computer languages that hinder your ability to craft code, but you put up with
editors that bind your fingers to someone else‚Äôs accepted practice. ---[[http://www.howardism.org/Technical/Emacs/why-emacs.html][Howard
Abrams]]
#+end_quote

*The Power of Text Manipulation:*
Emacs has ways to represent all kinds of information as text.

E.g., if want to make a regular expression rename of files in a directory,
there's no need to learn about a batch renaming tool: ~M-x dired <RET> M-x wdired-change-to-wdired-mode~ now simply perform a /usual/ find-and-replace, then
save with the /usual/ ~C-x C-s~ to effect the changes!

Likewise for other system utilities and services (‚Ä¢ÃÄ·¥ó‚Ä¢ÃÅ)Ÿà

Moreover, as will be shown below, you can literally use [[https://github.com/zachcurry/emacs-anywhere/#usage][Emacs anywhere]]
for textually input in your operating system --no copy-paste required.

*Keyboard Navigation and Alteration* Suppose you wrote a paragraph of text, and
wanted to ‚Äòborder‚Äô it up for emphasies in hypens. Using the mouse to navigate
along with a copy-paste of the hypens is vastely inferior to the incantation ~M-{
C-u 80 - RET M-} C-u 80 - RET~.  If we want to border up the previous ùìÉ-many
paragraphs, we simply prefix ~M-{,}~ above with ~C-u ùìÉ~ ---a manual approach would
have us count ùìÉ and slowly scroll.  ( Exercise: What incantation of keys
‚Äòunderlines‚Äô the current line with /only/ the necessary amount of dashes?
---Solution in the source file. )

Finally, here's some fun commands to try out:
- ~M-x doctor~ ---generalising the idea of rubber ducks
- ~M-x tetris~  or ~M-x gomoku~ or ~M-x snake~---a break with a classic
  - ~C-u ùìÉ M-x hanoi~ for the ùìÉ-towers of Hanoi
- ~M-x butterfly~ ---in reference to [[https://xkcd.com/378/][‚Äúreal programmers‚Äù]]

Before we get started‚Ä¶

*Why a monolithic configuration?*

Why am I keeping my entire configuration ---from those involving cosmetics &
prose to those of agendas & programming--- in one file?  Being monolithic ---‚Äúa
large, mountain-sized, indivisible block of stone‚Äù--- is generally not ideal in
nearly any project: E.g., a book is split into chapters and a piece of software
is partitioned into modules. Using Org-mode, we can still partition our setup
while remaining in one file. An Emacs configuration is a personal, leisurely
project, and one file is a simple architecture: I don't have to worry about many
files and the troubles of moving content between them; instead, I have headings
and move content almost instantaneously ---org-refile by pressing ~w~ at the start
of the reader. Moreover, being one file, it is easy to distribute and to extract
artefacts from it ---such as the README for Github, the HTML for my blog, the
colourful PDF rendition, and the all-important Emacs Lisp raw code
file. Moreover, with a single ~#~ I can quickly comment out whole sections,
thereby momentarily disabling features.

There's no point in being modular if there's nothing explaining what's going on,
so I document.

The [[#Conclusion---Why-Configuration-Files-Should-be-Literate][concluding]] section of this read further argues the benefits of maintaining
literate, and monolithic, configuration files. As a convention, I will try to
motivate the features I set up and I will prefix my local functions with, well,
~my/~ ---this way it's easy to see all my defined functions, and this way I cannot
accidentally shadow existing utilities. Moreover, besides browsing the web, I do
nearly everything in Emacs and so the start-up time is unimportant to me: Once
begun, I have no intention of spawning another instance nor closing the current
one. ( Upon an initial startup using this configuration, it takes a total of
121 seconds to install all the packages featured here. )

Enjoy!

* Booting Up
Let's decide on where we want to setup our declarations for personalising Emacs
to our needs. Then, let's bootstrap Emacs' primitive packaging mechanism with a
slick interface ---which not only installs Emacs packages but also programs at
the operating system level, all from inside Emacs!  Finally, let's declare who
we are and use that to setup Emacs email service.

** =~/.emacs= vs. =init.org=
/Emacs is extenible/: When Emacs is started, it tried to load a user's Lisp
program known as a initialisation file which specfies how Emacs should look and
behave for you.  Emacs looks for the init file using the filenames =~/.emacs.el,
~/.emacs,= or =~/.emacs.d/init.el= ---it looks for the first one that exists, in
that order; at least it does so on my machine.  Below we'll avoid any confusion
by /ensuring/ that only one of them is in our system.  Regardless, execute =C-h o
user-init-file= to see the name of the init file loaded. Having no init file is
tantamount to have an empty init file.

- One can read about the various Emacs initialisation files [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Init-File.html#Init-File][online]] or
  within Emacs by the sequence ~C-h i m emacs RET i init file RET~.
- A /friendly/ tutorial on ‚Äòbeginning a =.emacs= file‚Äô can be read
  [[https://www.gnu.org/software/emacs/manual/html_node/eintr/Beginning-init-File.html#Beginning-init-File][online]] or within Emacs by ~C-h i m emacs lisp intro RET i .emacs RET~.
- After inserting some lisp code and saving, such as ~(set-background-color
    "salmon")~, one can load the changes with ~M-x eval-buffer~.
- In a terminal, use ~emacs -Q~ to open emacs without any initialisation files.

Besides writing Lisp in an init file, one may use Emacs' customisation
interface, ~M-x customize~: Point and click to change Emacs to your needs. The
resulting customisations are, by default, automatically thrown into your init
file ---=~/.emacs= is created for you if you have no init file.  This interface is
great for beginners, but one major drawback is that it's a bit difficult to
share settings since it's not amicable to copy-pasting.

We shall use =~/.emacs.d/init.el= as the initialisation file so that /all/ of our
Emacs related files live in the /same/ directory: =~/.emacs.d/=.

A raw code file is difficult to maintain, especially for a /large/ system such as
Emacs. Instead, we're going with a ‚Äòliterate programming‚Äô approach: The
intialisation configuration is presented in an essay fromat, along with headings
and subheadings, intended for consumption by humans such as myself, that,
incidentally, can be ‚Äòtangled‚Äô into a raw code file that is comprehensible by a
machine. We achieve this goal using [[#Life-within-Org-mode][org-mode]] ---/Emacs' killer app/--- which is
discussed in great detail later on.

*** /Adventure time!/ ‚ÄúHoney, where's my init?‚Äù
Let's use the three possible locations for the initialisation files
to explore how Emacs finds them. Make the following three files.

_~/.emacs.el_
#+begin_src emacs-lisp :tangle no
;; Emacs looks for this first;
(set-background-color "chocolate3")
(message-box ".emacs.el says hello")
#+end_src
_~/.emacs_
#+begin_src emacs-lisp :tangle no
;; else; looks for this one;
(set-background-color "plum4")
(message-box ".emacs says hello")
#+end_src
_~/.emacs.d/init.el_
#+begin_src emacs-lisp :tangle no
;; Finally, if neither are found; it looks for this one.
(set-background-color "salmon")
(message-box ".emacs.d/init.el says hello")
#+end_src

Now restart your Emacs to see how there super tiny initilaisation files
affect your editor. Delete some of these files in-order for others to take effect!

*** /Adventure time!/ Using Emacs' Easy Customisation Interface
We have chosen not to keep configurations in ~~/.emacs~ since
Emacs may explicitly add, or alter, code in it.

Let's see this in action!

Execute the following to see additions to the ~~/.emacs~ have been added by
‚Äòcustom‚Äô.
1. =M-x customize-variable RET line-number-mode RET=
2. Then press: ~toggle~, ~state~, then ~1~.
3. Now take a look: =C-x C-f ~/.emacs=

*** Support for ‚ÄòCustom‚Äô
Let the Emacs customisation GUI insert configurations into its own file, not
touching or altering my initialisation file.  For example, I tend to have local
variables to produce ~README.org~'s and other matters, so Emacs' Custom utility
will remember to not prompt me each time for the safety of such local variables.
#+begin_src emacs-lisp
(setq custom-file "~/.emacs.d/custom.el")
(load custom-file)
#+end_src

Speaking of local variables, let's always ones we've already marked as safe
---see the bottom of the source of this file for an example of local variables.
( At one point, all my files had locals! )
#+begin_src emacs-lisp
(setq enable-local-variables :safe)
#+end_src

** =use-package= ---The start of =init.el=
There are a few ways to install packages ---run ~C-h C-e~ for a short overview.
The easiest, for a beginner, is to use the command ~package-list-packages~ then
find the desired package, press ~i~ to mark it for installation, then install all
marked packages by pressing ~x~.

- /Interactively/:  ~M-x list-packages~ to see all melpa packages that can install
  - Press ~Enter~ on a package to see its description.
- Or more quickly, to install, say, the haskell mode: ~M-x package-install RET
    unicode-fonts RET~.

‚ÄúFrom rags to riches‚Äù: Recently I switched to Mac ---first time trying the OS.
I had to do a few ~package-install~'s and it was annoying.  I'm looking for the
best way to package my Emacs installation ---including my installed packages and
configuration--- so that I can quickly install it anywhere, say if I go to
another machine.  It seems ~use-package~ allows me to configure and auto install
packages.  On a new machine, when I clone my ~.emacs.d~ and start Emacs, on the
first start it should automatically install and compile all of my packages
through ~use-package~ when it detects they're missing.

First we load ~package~, the built-in package manager.  It is by default only
connected to the GNU ELPA (Emacs Lisp Package Archive) repository, so we
extended it with other popular repositories; such as the much larger [[https://melpa.org/#/][MELPA]]
(Milkypostman's ELPA) ---it builds packages [[https://github.com/melpa/melpa][directly from the source-code
reposistories of developers]], rather than having all packages in one repository.
#+begin_src emacs-lisp
;; Make all commands of the ‚Äúpackage‚Äù module present.
(require 'package)

;; Internet repositories for new packages.
(setq package-archives '(("org"       . "http://orgmode.org/elpa/")
                         ("gnu"       . "http://elpa.gnu.org/packages/")
                         ("melpa"     . "http://melpa.org/packages/")
                         ("melpa-stable" . "http://stable.melpa.org/packages/")))

;; Actually get ‚Äúpackage‚Äù to work.
(package-initialize)
(package-refresh-contents)
#+end_src

- All installed packages are placed, by default, in =~/.emacs.d/elpa=.
- *Neato:* /If one module requires others to run, they will be installed automatically./

The declarative configuration tool [[https://github.com/jwiegley/use-package/][use-package]] is a
macro/interface that manages other packages and the way they interact.
- It allows us to tersely organise a package's configuration.
  - By default, ~(use-package foo)~ only loads a package, if it's on our system.
    - Use the standalone keyword ~:disabled~ to turn off loading
      a module that, say, you're not using anymore.
- It is /not/ a package manger, but we can make it one by having it automatically
  install modules, via Emacs packing mechanism, when they're not in our system.

  We achieve this by using the keyword option ~:ensure t~.
- Here are common keywords we will use, in super simplified terms.
  - ~:init   f‚ÇÅ ‚Ä¶ f‚Çô~  /Always/ executes code forms ~f·µ¢~ /before/ loading a package.
  - ~:diminish str~  Uses /optional/ string ~str~ in the modeline to indicate
    this module is active. Things we use often needn't take
    real-estate down there and so no we provide no ~str~.
  - ~:config f‚ÇÅ ‚Ä¶ f‚Çô~ /Only/ executes code forms ~f·µ¢~ /after/ loading a package.

    The remaining keywords only take affect /after/ a module loads.

  - ~:bind ((k‚ÇÅ . f‚ÇÅ) ‚Ä¶ (k‚Çô . f‚Çô)~ Lets us bind keys ~k·µ¢~, such as
    ~"M-s o"~, to functions, such as =occur=.
    - When /n = 1/, the extra outer parenthesis are not necessary.
  - ~:hook ((m‚ÇÅ ‚Ä¶ m‚Çô) . f)~ Enables functionality ~f~ whenever we're in one of the
    modes ~m·µ¢~, such as ~org-mode~. The ~. f~, along with the outermost parenthesis,
    is optional and defaults to the name of the package ---Warning: Erroneous
    behaviour happens if the package's name is not a function provided by the
    package; a common case is when package's name does /not/ end in ~-mode~,
    leading to the invocation ~((m‚ÇÅ ‚Ä¶ m‚Çô) . <whatever-the-name-is>-mode)~ instead.

    Additionally, when /n = 1/, the extra outer parenthesis are not necessary.

    Outside of =use-package=, one normally uses a ~add-hook~ clause.  Likewise, an
    ‚Äòadvice‚Äô can be given to a function to make it behave differently ---this is
    known as ‚Äòdecoration‚Äô or an ‚Äòattribute‚Äô in other languages.

  - ~:custom (k‚ÇÅ v‚ÇÅ d‚ÇÅ) ‚Ä¶ (k‚Çô v‚Çô d‚Çô)~ Sets a package's custom variables ~k·µ¢~ to have
    values ~v·µ¢~, along with /optional/ user documentation ~d·µ¢~ to explain to yourself,
    in the future, why you've made this decision.

    This is essentially ~setq~ within ~:config~.

We now bootstrap ~use-package~.
#+begin_src emacs-lisp
(unless (package-installed-p 'use-package)
  (package-install 'use-package))

(eval-when-compile (require 'use-package))
#+end_src

We can now invoke ~(use-package XYZ :ensure t)~ which should check for the ~XYZ~
package and make sure it is accessible.  If not, the ~:ensure t~ part tells
~use-package~ to download it ---using the built-in ~package~ manager--- and place it
somewhere accessible, in =~/.emacs.d/elpa/= by default.  By default we would like
to download packages, since I do not plan on installing them manually by
downloading Lisp files and placing them in the correct places on my system.
#+begin_src emacs-lisp
(setq use-package-always-ensure t)
#+end_src
The use of ~:ensure t~ only installs absent modules, but it does no updating.
Let's set up [[https://github.com/rranelli/auto-package-update.el][an auto-update mechanism]].
#+begin_src emacs-lisp
(use-package auto-package-update
  :config
  ;; Delete residual old versions
  (setq auto-package-update-delete-old-versions t)
  ;; Do not bother me when updates have taken place.
  (setq auto-package-update-hide-results t)
  ;; Update installed packages at startup if there is an update pending.
  (auto-package-update-maybe))
#+end_src

Here's another example use of ~use-package~.  Later on, I have a ‚Äúshow recent files
pop-up‚Äù command set to ~C-x C-r~; but what if I forget? This mode shows me all key
completions when I type ~C-x~, for example.  Moreover, I will be shown other
commands I did not know about! Neato :-)
#+begin_src emacs-lisp
;; Making it easier to discover Emacs key presses.
(use-package which-key
  :diminish
  :config (which-key-mode)
          (which-key-setup-side-window-bottom)
          (setq which-key-idle-delay 0.05))
#+end_src
‚ü® Honestly, I seldom even acknowledge this pop-up; but it's always nice to show
to people when I'm promoting Emacs. ‚ü©

Above, the ~:diminish~ keyword indicates that we do not want the mode's name to be
shown to us in the modeline ---the area near the bottom of Emacs.  It does so by
using the ~diminish~ package, so let's install that.
#+begin_src emacs-lisp
(use-package diminish
  :demand t
  :config ;; Let's hide some markers.
    (diminish  'org-indent-mode))
#+end_src

Here are other packages that I want to be installed onto my machine.
#+begin_src emacs-lisp
;; Efficient version control.
;;
;; Bottom of Emacs will show what branch you're on
;; and whether the local file is modified or not.
(use-package magit
  :config (global-set-key (kbd "C-x g") 'magit-status))

(use-package htmlize)
;; Main use: Org produced htmls are coloured.
;; Can be used to export a file into a coloured html.

;; Quick BibTeX references, sometimes.
(use-package biblio)

;; Get org-headers to look pretty! E.g., * ‚Üí ‚äô, ** ‚Ü¶ ‚óØ, *** ‚Ü¶ ‚òÖ
;; https://github.com/emacsorphanage/org-bullets
(use-package org-bullets
  :hook (org-mode . org-bullets-mode))

;; Haskell's cool
(use-package haskell-mode)

;; Lisp libraries with Haskell-like naming.
(use-package dash)    ;; ‚ÄúA modern list library for Emacs‚Äù
(use-package s   )    ;; ‚ÄúThe long lost Emacs string manipulation library‚Äù.

;; Library for working with system files;
;; e.g., f-delete, f-mkdir, f-move, f-exists?, f-hidden?
(use-package f)
#+end_src

Note:
- [[https://github.com/magnars/dash.el][dash]]: ‚ÄúA modern list library for Emacs‚Äù
  - E.g., ~(--filter (> it 10) (list 8 9 10 11 12))~
- [[https://github.com/magnars/s.el][s]]: ‚ÄúThe long lost Emacs string manipulation library‚Äù.
  - E.g., ~s-trim, s-replace, s-join~.

Remember that snippet for ~undo-tree~ in the introductory section?
Let's activate it now, after ~use-package~ has been setup.
#+begin_src emacs-lisp :noweb yes
  <<undo-tree-setup>>
#+end_src

** =README= ---From =init.org= to =init.el=
Rather than manually extracting the Lisp code from this literate document each
time we alter it, let's instead add a ‚Äòhook‚Äô ---a method that is invoked on a
particular event, in this case when we save the file.  More precisely, in this
case, ~C-x C-s~ is a normal save whereas ~C-u C-x C-s~ is a save after forming
~init.elc~ and ~README.md~.

#+name: enable making init and readme
#+begin_src emacs-lisp :eval never-export
(defun my/make-init-el-and-README ()
  "Tangle an el and a github README from my init.org."
  (interactive "P") ;; Places value of universal argument into: current-prefix-arg
  (when current-prefix-arg
    (let* ((time      (current-time))
           (_date     (format-time-string "_%Y-%m-%d"))
           (.emacs    "~/.emacs")
           (.emacs.el "~/.emacs.el"))
      ;; Make README.org
      (save-excursion
        (org-babel-goto-named-src-block "make-readme")
        (org-babel-execute-src-block))

      ;; remove any other initialisation file candidates
      (ignore-errors
        (f-move .emacs    (concat .emacs _date))
        (f-move .emacs.el (concat .emacs.el _date)))

      ;; Make init.el
      (org-babel-tangle)
      (byte-compile-file "~/.emacs.d/init.el")
      (load-file "~/.emacs.d/init.el")

      ;; Acknowledgement
      (message "Tangled, compiled, and loaded init.el; and made README.md ‚Ä¶ %.06f seconds"
               (float-time (time-since time))))))

(add-hook 'after-save-hook 'my/make-init-el-and-README nil 'local-to-this-file-please)
#+end_src

Where the following block has ~#+NAME: make-readme~ before it.
This source block generates the ~README~ for the associated Github repository.
#+name: make-readme
#+begin_src emacs-lisp :tangle no :export_never t
;; Update the table of contents in this file.
(save-buffer)
(with-temp-buffer
    (insert
    "#+EXPORT_FILE_NAME: README.org

     # Logos and birthday present painting
     ,#+HTML:" (s-collapse-whitespace (concat
    " <p align=\"center\">
       <img src=\"emacs-logo.png\" width=150 height=150/>
     </p>

     <p align=\"center\">
        <a href=\"https://www.gnu.org/software/emacs/\">
             <img src=\"https://img.shields.io/badge/GNU%20Emacs-" emacs-version "-b48ead.svg?style=plastic\"/></a>
        <a href=\"https://orgmode.org/\"><img src=\"https://img.shields.io/badge/org--mode-" org-version "-489a9f.svg?style=plastic\"/></a>
     </p>

     <p align=\"center\">
       <img src=\"emacs-birthday-present.png\" width=200 height=250/>
     </p>
    "))

   ;; My Literate Setup; need the empty new lines for the export
   "

     I enjoy reading others' /literate/ configuration files and
     incorporating what I learn into my own. The result is a
     sufficiently well-documented and accessible read that yields
     a stylish and functional system (‚Ä¢ÃÄ·¥ó‚Ä¢ÃÅ)Ÿà

     This ~README.org~ has been automatically generated from my
     configuration and its contents below are accessible
     in (outdated) blog format, with /colour/, or as colourful
     PDF, [[https://alhassy.github.io/init/][here]]. Enjoy
     :smile:

     ,#+INCLUDE: init.org
    ")

    ;; No code execution on export
    ;; ‚ü™ For a particular block, we use ‚Äú:eval never-export‚Äù. ‚ü´
    (let ((org-export-use-babel nil))
      (org-mode)
      (org-org-export-to-org)))
#+end_src
Alternatively, evaluate the above source block with ~C-c C-c~ to produce a ~README~
file.

Notes:
- Github supports several markup languages, one of which is Org-mode.
  - It seems that Github uses [[https://github.com/bdewey/org-ruby][org-ruby]] to convert org-mode to html.
  - [[https://github.com/novoid/github-orgmode-tests][Here]] is a repo demonstrating how Github interprets Org-mode files.
  - org-ruby supports inline ~#+HTML~ but [[https://github.com/wallyqs/org-ruby/issues/51][not html blocks]].

- It seems coloured HTML does not render well:
  #+begin_src emacs-lisp :tangle no
  (org-html-export-to-html)
  (shell-command "mv README.html README.md")
  #+end_src
- [[https://orgmode.org/manual/JavaScript-support.html][JavaScript supported display of web pages]] with:
  #+begin_src org :tangle no
  ,#+INFOJS_OPT: view:info toc:t buttons:t
  #+end_src
  This looks nice for standalone pages, but doesn't incorporate nicely with
  github README.org.

The above mentioned package [[https://github.com/alphapapa/org-make-toc][org-make-toc]], which creates an up-to-date table of
contents in an org file, at any heading tagged ~:TOC:~.  It's useful primarily for
README files on Github. There is also [[https://github.com/snosov1/toc-org][toc-org]], but it provides only a top-level
TOC; whereas this package allows TOCs at the sibling level, say, to produce a
TOC of only the subsections of a particular heading.  Org-make-toc has much more
features regarding TOC creation.
#+begin_src emacs-lisp
(use-package org-make-toc
  ;; Automatically update toc when saving an Org file.
  :hook (org-mode . org-make-toc-mode))

(use-package toc-org
  ;; Automatically update toc when saving an Org file.
  :hook (org-mode . toc-org-mode))
#+end_src

I'm not sure how I feel about actually having the Github-serving TOC in my
source file. It's nice to have around, from an essay-perspecive, but it breaks
HTML export since its links are /not/ well-behaved; e.g., ~:ignore:~-ed headlines
appear in the toc, but do not link to any visible heading in the HTML; likewise,
headings with URLS in their names break. As such, below I've developed a way to
erase it altogether ---alternatively, one could mark the toc as ~:noexport:~, but
this would then, in my current approach, not result in a toc in the resulting
README.
#+begin_src emacs-lisp
(cl-defun my/org-replace-tree-contents (heading &key (with "") (offset 0))
  "Replace the contents of org tree HEADING with WITH, starting at OFFSET.

Clear a subtree leaving first 3 lines untouched  ‚áê  :offset 3
Deleting a tree & its contents                   ‚áê  :offset -1, or any negative number.
Do nothing to a tree of 123456789 lines          ‚áê  :offset 123456789

Precondition: offset < most-positive-fixnum; else we wrap to a negative number."
  (interactive)
  (save-excursion
    (beginning-of-buffer)
    (re-search-forward (format "^\\*+ %s" (regexp-quote heading)))
    ;; To avoid ‚Äòforward-line‚Äô from spilling onto other trees.
    (org-narrow-to-subtree)
    (org-mark-subtree)
    ;; The 1+ is to avoid the heading.
    (dotimes (_ (1+ offset)) (forward-line))
    (delete-region (region-beginning) (region-end))
    (insert with)
    (widen)))

;; Erase :TOC: body ---provided we're using toc-org.
;; (my/org-replace-tree-contents "Table of Contents")
#+end_src
** Installing Emacs packages directly from source
[[https://github.com/quelpa/quelpa-use-package][Quelpa]] allows us to build Emacs packages directly from source repositories.  It
derives its name from the German word /Quelle/, for /souce/ [code], adjoined to
ELPA.  Its ~use-package~ interface allows us to use ~use-package~ like normal but
when we want to install a file from souce we use the keyword ~:quelpa~.

#+begin_src emacs-lisp
(use-package quelpa
  :custom (quelpa-upgrade-p t "Always try to update packages")
  :config
  ;; Get ‚Äòquelpa-use-package‚Äô via ‚Äòquelpa‚Äô
  (quelpa
   '(quelpa-use-package
     :fetcher git
     :url "https://github.com/quelpa/quelpa-use-package.git"))
  (require 'quelpa-use-package))
#+end_src

Let's use this to obtain an improved info-mode from the EmacsWiki. [Disabled for
now]
#+begin_src emacs-lisp :tangle no
(use-package info+
  :disabled
  :quelpa (info+ :fetcher wiki :url "https://www.emacswiki.org/emacs/info%2b.el"))
#+end_src

** =magit= ---Emacs' porcelain interface to git
Let's setup an Emacs ‚Äòporcelain‚Äô interface to git ---it makes working with
version control tremendously convenient.  Moreover, I add a little pop-up so
that I don't forget to commit often!

Why use ~magit~ as the interface to the git version control system?  In ~magit~
buffer nearly everything can be acted upon: Press =return=, or =space=, to see
details and =tab= to see children items, usually.

First, let's setup our git credentials.
#+begin_src emacs-lisp
;; See here for a short & useful tutorial:
;; https://alvinalexander.com/git/git-show-change-username-email-address
(when (equal ""
(shell-command-to-string "git config user.name"))
  (shell-command "git config --global user.name \"Musa Al-hassy\"")
  (shell-command "git config --global user.email \"alhassy@gmail.com\""))
#+end_src

Below is my personal quick guide to working with magit ---for a full tutorial
see [[http://jr0cket.co.uk/2012/12/driving-git-with-emacs-pure-magic-with.html.html][jr0cket's blog]].

- ~dired~ :: See the contents of a particular directory.

- ~magit-init~ :: Put a project under version control.
     The mini-buffer will prompt you for the top level folder version.
     A ~.git~ folder will be created there.

- ~magit-status~ , ~C-x g~ :: See status in another buffer.
     Press ~?~ to see options, including:
  - g :: Refresh the status buffer.
  - TAB :: See collapsed items, such as what text has been changed.
  - ~q~ :: Quit magit, or go to previous magit screen.
  - ~s~ :: Stage, i.e., add, a file to version control.
       Add all untracked files by selecting the /Untracked files/ title.

       [[https://softwareengineering.stackexchange.com/a/119807/185815][The staging area is akin to a pet store; commiting is taking the pet home.]]

  - ~k~ :: Kill, i.e., delete a file locally.
  - ~K~ :: This' ~(magit-file-untrack)~ which does ~git rm --cached~.
  - ~i~ :: Add a file to the project ~.gitignore~ file. Nice stuff =)
  - ~u~ :: Unstage a specfif staged change highlighed by cursor.
       ~C-u s~ stages everything --tracked or not.
  - ~c~ :: Commit a change.
    - A new buffer for the commit message appears, you write it then
      commit with ~C-c C-c~ or otherwise cancel with ~C-c C-k~.
      These commands are mentioned to you in the minibuffer when you go to commit.
    - You can provide a commit to /each/ altered chunk of text!
      This is super neat, you make a series of local such commits rather
      than one nebulous global commit for the file. The ~magit~ interface
      makes this far more accessible than a standard terminal approach!
    - You can look at the unstaged changes, select a /region/, using ~C-SPC~ as usual,
      and commit only that if you want!
    - When looking over a commit, ~M-p/n~ to efficiently go to previous or next altered sections.
    - Amend a commit by pressing ~a~ on ~HEAD~.

  - ~d~ :: Show differences, another ~d~ or another option.
    - This is magit! Each hunk can be acted upon; e.g., ~s~ or ~c~ or ~k~ ;-)
  - ~v~ :: Revert a commit.
  - ~x~ :: Undo last commit. Tantamount to ~git reset HEAD~~ when cursor is on most recent
       commit; otherwise resets to whatever commit is under the cursor.
  - ~l~ :: Show the log, another ~l~ for current branch; other options will be displayed.
    - Here ~space~ shows details in another buffer while cursour remains in current
      buffer and, moreover, continuing to press ~space~ scrolls through the other buffer!
      Neato.
  - ~P~ :: Push.
  - ~F~ :: Pull.
  - ~:~ :: Execute a raw git command; e.g., enter ~whatchanged~.

Notice that every time you press one of these commands, a ‚Äòpop-up‚Äô of realted
git options appears! Thus not only is there no need to memorise many of them,
but this approach makes /discovering/ other commands easier.

Below are the git repos I'd like to clone ---along with a function to do so
quickly.
#+begin_src emacs-lisp
(use-package magit)

;; Do not ask about this variable when cloning.
(setq magit-clone-set-remote.pushDefault t)

(cl-defun maybe-clone (remote &optional (local (concat "~/" (file-name-base remote))))
  "Clone a REMOTE repository if the LOCAL directory does not exist.

Yields ‚Äòrepo-already-exists‚Äô when no cloning transpires,
otherwise yields ‚Äòcloned-repo‚Äô.

LOCAL is optional and defaults to the base name; e.g.,
if REMOTE is https://github.com/X/Y then LOCAL becomes ~/Y."
  (if (file-directory-p local)
      'repo-already-exists
    (async-shell-command (concat "git clone " remote " " local))
    (add-to-list 'magit-repository-directories `(,local   . 0))
    'cloned-repo))

(maybe-clone "https://github.com/alhassy/emacs.d" "~/.emacs.d")
(maybe-clone "https://github.com/alhassy/alhassy.github.io")
(maybe-clone "https://github.com/alhassy/CheatSheet")
(maybe-clone "https://github.com/alhassy/ElispCheatSheet")
(maybe-clone "https://github.com/alhassy/CatsCheatSheet")
(maybe-clone "https://github.com/alhassy/islam")

;; For brevity, many more ‚Äòmaybe-clone‚Äô clauses are hidden in the source file.
#+end_src
Let's always notify ourselves of a file that has [[https://tpapp.github.io/post/check-uncommitted/][uncommited changes]]
---we might have had to step away from the computer and forgotten to commit.
#+begin_src emacs-lisp
(require 'magit-git)

(defun my/magit-check-file-and-popup ()
  "If the file is version controlled with git
  and has uncommitted changes, open the magit status popup."
  (let ((file (buffer-file-name)))
    (when (and file (magit-anything-modified-p t file))
      (message "This file has uncommited changes!")
      (when nil ;; Became annyoying after some time.
      (split-window-below)
      (other-window 1)
      (magit-status)))))

;; I usually have local variables, so I want the message to show
;; after the locals have been loaded.
(add-hook 'find-file-hook
  '(lambda ()
      (add-hook 'hack-local-variables-hook 'my/magit-check-file-and-popup)))
#+end_src

Finally, one of the main points for using version control is to have access to
historic versions of a file. The following utility allows us to ~M-x
git-timemachine~ on a file and use ~p/n/g/q~ to look at previous, next, goto
arbitrary historic versions, or quit.
#+begin_src emacs-lisp
(use-package git-timemachine)
#+end_src
If we want to roll back to a previous version, we just ~write-file~ or ~C-x C-s~ as
usual! The power of text!

** Syncing to the System's =$PATH=
For one reason or another, on OS X it seems that an Emacs instance
begun from the terminal may not inherit the terminal's environment
variables, thus making it difficult to use utilities like ~pdflatex~
when Org-mode attempts to produce a PDF.

#+begin_src emacs-lisp
(use-package exec-path-from-shell
  :init
  (when (memq window-system '(mac ns x))
    (exec-path-from-shell-initialize)))
#+end_src

See the [[https://github.com/purcell/exec-path-from-shell][exec-path-from-shell]] documentation for setting other environment variables.
** Installing OS packages, and automatically keeping my system up to data, from within Emacs
Sometimes Emacs packages depend on existing system binaries, ~use-package~ let's
us ensure these exist using the ~:ensure-system-package~ keyword extension.

- This is like ~:ensure t~ but operates at the OS level and uses your default
  OS package manager.

Let's obtain the extension.
#+begin_src emacs-lisp
;; Auto installing OS system packages
(use-package use-package-ensure-system-package)

;; Ensure our operating system is always up to date.
;; This is run whenever we open Emacs & so wont take long if we're up to date.
;; It happens in the background ^_^
(system-packages-update)
#+end_src

After an update to Mac OS, one may need to [[https://emacs.stackexchange.com/questions/53026/how-to-restore-file-system-access-in-macos-catalina][restore file system access privileges
to Emacs]].

Here's an example use for Emacs packages that require OS packages:
#+begin_src emacs-lisp :tangle no
(shell-command-to-string "type rg") ;; ‚áí rg not found
(use-package rg
  :ensure-system-package rg) ;; ‚áí There's a buffer *system-packages*
                             ;;   installing this tool at the OS level!
#+end_src
If you look at the ~*Messages*~ buffer, via ~C-h e~, on my machine it says
~brew install rg: finished~ ---it uses ~brew~ which is my OS package manager!

- The [[https://github.com/jwiegley/use-package#use-package-ensure-system-package][use-package-ensure-system-package]] documentation for a flurry of use cases.

The extension makes use of [[https://gitlab.com/jabranham/system-packages][system-packages]]; see its documentation to learn
more about managing installed OS packages from within Emacs. This is itself
a powerful tool, however it's interface ~M-x system-packages-install~ leaves much
to be desired ---namely, tab-compleition listing all available packages,
seeing their descriptions, and visiting their webpages.
This is remedied by [[https://github.com/emacs-helm/helm-system-packages][M-x helm-system-packages]] then ~RET~ to see a system
package's description, or ~TAB~ for the other features!
/This is so cool!/

#+begin_src emacs-lisp
;; An Emacs-based interface to the package manager of your operating system.
(use-package helm-system-packages)
#+end_src

The Helm counterpart is great for /discovarability/, whereas
the plain ~system-packages~ is great for /programmability/.

It is tedious to arrange my program windows manually, and as such I love tiling
window managers, which automatically arrange them.  I had been using [[https://xmonad.org][xmonad]]
until recently when I obtained a Mac machine and now use [[https://ianyh.com/amethyst/][Amethyst]] ---‚ÄúTiling
window manager for macOS along the lines of xmonad.‚Äù

#+begin_src emacs-lisp
;; Unlike the Helm variant, we need to specify our OS pacman.
(setq system-packages-package-manager 'brew)
#+end_src
#+begin_src emacs-lisp :tangle no
;; Use ‚Äúbrew cask install‚Äù instead of ‚Äúbrew install‚Äù for installing programs.
(setf (nth 2 (assoc 'brew system-packages-supported-package-managers))
      '(install . "brew cask install"))

;; If the given system package doesn't exist; install it.
(system-packages-ensure "amethyst")
#+end_src

Neato! Now I can live in Emacs even more ^_^

** ‚ÄúBeing at the Helm‚Äù ---Completion & Narrowing Framework
Whenever we have a choice to make from a list, [[http://tuhdo.github.io/helm-intro.html][Helm]] provides possible
completions and narrows the list of choices as we type.  This is extremely
helpful for when switching between buffers, =C-x b=, and discovering & learning
about other commands!  E.g., press ~M-x~ to see recently executed commands and
other possible commands! Press ~M-x~ and just start typing, methods mentioning
what you've typed are suddenly listed!

| Remembrance comes with time, until then /ask/ Emacs! |

/Try and be grateful!/
#+begin_src emacs-lisp
(use-package helm
 :diminish
 :init (helm-mode t)
 :bind (("M-x"     . helm-M-x)
        ("C-x C-f" . helm-find-files)
        ("C-x b"   . helm-mini)     ;; See buffers & recent files; more useful.
        ("C-x r b" . helm-filtered-bookmarks)
        ("C-x C-r" . helm-recentf)  ;; Search for recently edited files
        ("C-c i"   . helm-imenu)
        ("C-h a"   . helm-apropos)
        ;; Look at what was cut recently & paste it in.
        ("M-y" . helm-show-kill-ring)

        :map helm-map
        ;; We can list ‚Äòactions‚Äô on the currently selected item by C-z.
        ("C-z" . helm-select-action)
        ;; Let's keep tab-completetion anyhow.
        ("TAB"   . helm-execute-persistent-action)
        ("<tab>" . helm-execute-persistent-action)))
#+end_src

Helm provides generic functions for completions to replace
tab-completion in Emacs with no loss of functionality.

- The =execute-extended-command=, the default ‚ÄúM-x‚Äù, is replaced with ~helm-M-x~
  which shows possible command completions.

  Likewise with ~apropos~, which is helpful for looking up commands.
  It shows all meaningful Lisp symbols whose names match a given pattern.

- The ‚ÄòHelm-mini‚Äô, ~C-x b~, shows all buffers, recently opened files,
  bookmarks, and allows us to create new bookmarks and buffers!

- The ‚ÄòHelm-imenu‚Äô, ~C-c i~, yields a a menu of all ‚Äútop-level items‚Äù in a file;
  e.g., functions and constants in source code or headers in an org-mode file.

  ‚ü≥ Nifty way to familarise yourself with a new code base, or one from a while
  ago.

- When Helm is active, ~C-x~ lists possible course of actions on the currently
  selected item.

When ~helm-mode~ is enabled, even help commands make use of it.
E.g., ~C-h o~ runs ~describe-symbol~ for the symbol at point,
and ~C-h w~ runs ~where-is~ to find the key binding of the symbol at point.
Both show a pop-up of other possible commands.

       Here's a nifty tutorial:
[[http://tuhdo.github.io/helm-intro.html][A package in a league of its own: Helm]]

Let's ensure ~C-x b~ shows us: Current buffers, recent files, and bookmarks
---as well as the ability to create bookmarks, which is via ~C-x r b~ manually.
For example, I press ~C-x b~ then type any string and will have the option of
making that a bookmark referring to the current location I'm working in, or
jump to it if it's an existing bookmark, or make a buffer with that name,
or find a file with that name.
#+begin_src emacs-lisp
(setq helm-mini-default-sources '(helm-source-buffers-list
                                    helm-source-recentf
                                    helm-source-bookmarks
                                    helm-source-bookmark-set
                                    helm-source-buffer-not-found))
#+end_src

Incidentally, Helm even provides an [[http://tuhdo.github.io/helm-intro.html#orgheadline24][interface]] for the ~top~ program via
~helm-top~. It also serves as an interface to popular search engines
and over 100 websites such as ~google, stackoverflow, ctan~, and ~arxiv~.
#+begin_src emacs-lisp
(system-packages-ensure "surfraw")
; ‚áí  ‚ÄúM-x helm-surfraw‚Äù or ‚ÄúC-x c s‚Äù
#+end_src
If we want to perform a google search, with interactive suggestions,
then invoke ~helm-google-suggest~ ---which can be acted for other serves,
such as Wikipedia or Youtube by ~C-z~. For more google specific options,
there is the ~google-this~ package.

Let's switch to a powerful searching mechanism -- [[https://github.com/ShingoFukuyama/helm-swoop][helm-swoop]].  It allows us to
not only search the current buffer but also the other buffers and to make live
edits by pressing ~C-c C-e~ when a search buffer exists. Incidentally, executing
~C-s~ on a word, region, will search for that particular word, region; then make
changes with ~C-c C-e~ and apply them by ~C-x C-s~.
#+begin_src emacs-lisp
(use-package helm-swoop
  :bind  (("C-s"     . 'helm-swoop)           ;; search current buffer
          ("C-M-s"   . 'helm-multi-swoop-all) ;; Search all buffer
          ;; Go back to last position where ‚Äòhelm-swoop‚Äô was called
          ("C-S-s" . 'helm-swoop-back-to-last-point))
  :custom (helm-swoop-speed-or-color nil "Give up colour for speed.")
          (helm-swoop-split-with-multiple-windows nil "Do not split window inside the current window."))
#+end_src

- ~C-u ùìÉ C-s~ does a search but showing ùìÉ contextual lines!
- ~helm-multi-swoop-all~, ~C-M-s~, lets us grep files anywhere!

Finally, note that there is now a ~M-x helm-info~ command to show documentation,
possibly with examples, of the packages installed. For example,
~M-x helm-info RET dash RET -parition RET~ to see how the parition function from the
dash library works via examples ;-)
** Having a workspace manager in Emacs
I've loved using XMonad as a window tiling manager.  I've enjoyed the ability to
segregate my tasks according to what ‚Äòproject‚Äô I'm working on; such as research,
marking, Emacs play, etc.  With [[https://github.com/nex3/perspective-el][perspective]], I can do the same thing :-)

That is, I can have a million buffers, but only those that belong to a workspace
will be visible when I'm switching between buffers, for example.
( The awesome-tab and centaur-tab, mentioned elsewhere here, can be used to
achieve the same thing by ‚Äògrouping buffers together‚Äô. )

#+begin_src emacs-lisp
(use-package perspective
  :config ;; Activate it.
          (persp-mode)
          ;; In the modeline, tell me which workspace I'm in.
          (persp-turn-on-modestring))
#+end_src

All commands are prefixed by ~C-x x~; main commands:
- ~s, n/‚Üí, p/‚Üê~ :: ‚ÄòS‚Äôelect a workspace to go to or create it, or go to ‚Äòn‚Äôext
     one, or go to ‚Äòp‚Äôrevious one.
- ~c~ :: Query a perspective to kill.
- ~r~ :: Rename a perspective.
- ~A~ :: Add buffer to current perspective & remove it from all others.

As always, since we've installed ~which-key~, it suffices to press ~C-x x~ then look
at the resulting menu üòÉ
** Excellent PDF Viewer
Let's install the [[https://github.com/politza/pdf-tools][pdf-tools]] library for viewing PDFs in Emacs.
#+begin_src emacs-lisp
(use-package pdf-tools
  ; :init   (system-packages-ensure "pdf-tools")
  :custom (pdf-tools-handle-upgrades nil)
          (pdf-info-epdfinfo-program "/usr/local/bin/epdfinfo")
  :config (pdf-tools-install))

;; Now PDFs opened in Emacs are in pdfview-mode.
#+end_src

Besides the expected PDF viewing utilities, such as search, annotation, and continuous scrolling;
with a simple mouse right-click, we can even select a ‚Äòmidnight‚Äô rendering mode which may be
easier on the eyes. For more, see the brief [[https://www.dailymotion.com/video/x2bc1is][pdf-tools-tourdeforce]] demo.

** Who am I? ---Using Gnus for Gmail
Let's set the following personal Emacs-wide variables ---to be used in other
locations besides email.
#+begin_src emacs-lisp
(setq user-full-name    "Musa Al-hassy"
      user-mail-address "alhassy@gmail.com")
#+end_src

For some fun, run this cute method.
#+begin_src emacs-lisp :tangle no
(animate-birthday-present user-full-name)
#+end_src

By default, in Emacs, we may send mail: Write it in Emacs with ~C-x m~,
then press ~C-c C-c~ to have it sent via your OS's default mailing system
---mine appears to be Gmail via the browser. Or cancel sending mail with
~C-c C-k~ ---the same commands for org-capturing, discussed below (‚Ä¢ÃÄ·¥ó‚Ä¢ÃÅ)Ÿà

To send and read email in Emacs we use [[https://en.wikipedia.org/wiki/Gnus][GNUS]], which, like GNU itself, is a
recursive acronym: GNUS Network User Service.

1. Execute, rather place in your init:
   #+begin_src emacs-lisp
        (setq message-send-mail-function 'smtpmail-send-it)
   #+end_src
   Revert to the default OS mailing method by setting this variable to
   ~mailclient-send-it~.

2. Follow only the [[https://www.emacswiki.org/emacs/GnusGmail#toc1][quickstart here]]; namely, make a file named ~~/.gnus~ containing:
   #+begin_src emacs-lisp :tangle ~/.gnus
        ;; user-full-name and user-mail-address should be defined

   (setq gnus-select-method
         '(nnimap "gmail"
                  (nnimap-address "imap.gmail.com")
                  (nnimap-server-port "imaps")
                  (nnimap-stream ssl)))

   (setq smtpmail-smtp-server "smtp.gmail.com"
         smtpmail-smtp-service 587
         gnus-ignored-newsgroups "^to\\.\\|^[0-9. ]+\\( \\|$\\)\\|^[\"]\"[#'()]")
   #+end_src

3. Enable ‚Äú2 step authentication‚Äù for Gmail following [[https://emacs.stackexchange.com/a/33309/10352][these]] instructions.

4. You will then obtain a secret password, the ~x~ marks below, which you insert
   in a file named ~~/.authinfo~ as follows ---using your email address.
   #+begin_src shell :tangle no
        machine imap.gmail.com login alhassy@gmail.com password xxxxxxxxxxxxxxxx port imaps
        machine smtp.gmail.com login alhassy@gmail.com password xxxxxxxxxxxxxxxx port 587
   #+end_src

5. In Emacs, ~M-x gnus~ to see what's there.

   Or compose mail with ~C-x m~ then send it with ~C-c C-c~.
   - Press ~C-h m~ to learn more about message mode for mail composition; or
     read the [[https://www.gnus.org/manual/message.pdf][Message Manual]].

#+begin_src emacs-lisp
;; After startup, if Emacs is idle for 5seconds, then start Gnus.
;; Gnus is slow upon startup since it fetches all mails upon startup.
;; (run-with-idle-timer 5 nil #'gnus)
#+end_src

Learn more by reading [[https://www.gnu.org/software/emacs/manual/html_mono/gnus.html#Top][The Gnus Newsreader Manual]]; also available within Emacs by
~C-h i m gnus~ (‚Ä¢ÃÄ·¥ó‚Ä¢ÃÅ)Ÿà

- Or look at the [[https://www.gnu.org/software/emacs/refcards/pdf/gnus-refcard.pdf][Gnus Reference Card]].
- Or, less comprehensively, this [[https://github.com/redguardtoo/mastering-emacs-in-one-year-guide/blob/master/gnus-guide-en.org#subscribe-groups][outline]].

[[https://www.emacswiki.org/emacs/GnusTutorial][EmacsWiki]] has a less technical and more user friendly tutorial.

*** Prettifications
Let's add the icon ÓÖò near my mail groups ^_^
#+begin_src emacs-lisp
;; Fancy icons for Emacs
;; Only do this once:
(use-package all-the-icons)
  ; :config (all-the-icons-install-fonts 'install-without-asking)

;; Make mail look pretty
(use-package all-the-icons-gnus
  :config (all-the-icons-gnus-setup))

;; While we're at it: Make dired, ‚Äòdir‚Äôectory ‚Äòed‚Äôitor, look pretty
(use-package all-the-icons-dired
  :hook (dired-mode . all-the-icons-dired-mode))
#+end_src

Next, let's paste in some [[http://groups.google.com/group/gnu.emacs.gnus/browse_thread/thread/a673a74356e7141f][eye-candy for Gnus]]:
#+begin_src emacs-lisp
(setq gnus-sum-thread-tree-vertical        "‚îÇ"
      gnus-sum-thread-tree-leaf-with-other "‚îú‚îÄ‚ñ∫ "
      gnus-sum-thread-tree-single-leaf     "‚ï∞‚îÄ‚ñ∫ "
      gnus-summary-line-format
      (concat
       "%0{%U%R%z%}"
       "%3{‚îÇ%}" "%1{%d%}" "%3{‚îÇ%}"
       "  "
       "%4{%-20,20f%}"
       "  "
       "%3{‚îÇ%}"
       " "
       "%1{%B%}"
       "%s\n"))
#+end_src

*** Super Terse Tutorial
In gnus, by default items you've looked at disappear ---i.e., are archived.
They can still be viewed in, say, your online browser if you like.
In the ~Group~ view, ~R~ resets gnus, possibly retriving mail or alterations
from other mail clients. ~q~ exits gnus in ~Group~ mode, ~q~ exits the particular
view to go back to summary mode. Only after pressing ~q~ from within a group
do changes take effect on articles ---such as moves, reads, deletes, etc.

- Expected keys: ~RET~ enter/open an item, ~q~ quit and return to previous view, ~g~
  refresh view ---i.e., ‚Äòg‚Äôet new articles.

- =RET=: Enter a group by pressing, well, the enter key.
  - Use ~SPC~ to open a group and automatically one first article there.
  - Use ~C-u RET~ to see all mail in a folder instead of just unread mail.

- Only groups/folders with unread mail will be shown, use ~L/l~ to toggle between
  listing all groups.

- ~SPC, DEL~ to scroll forward and backward; or ~C-v, M-v~ as always.

- =G G=: Search mail at server side in the group buffer.
  - Limit search to particular folders/groups by marking them with ~#~, or
    unmarking them with ~M-#~.

- ~/ /,a:~ Filter mail according to subject or author; there are many
  other options, see [[https://www.gnu.org/software/emacs/manual/html_mono/gnus.html#Limiting][¬ß3.8 Limiting]].

- =d=:  Mark an article as done, i.e., read it and it can be archived.

- =!=: Mark an article as read, but to be kept around ---e.g., you have not
  replied to it, or it requires more reading at a later time.

  This lets us read mail offline; cached mail is found at =~/News/cache/=.

  #+begin_src emacs-lisp :tangle "~/.gnus"
    (setq gnus-use-cache 'use-as-much-cache-as-possible)
  #+end_src

- =B m=:  Move an article, in its current state, to another group ---i.e.,
  ‚Äòlabel‚Äô using Gmail parlance.

  Something to consider doing when finished with an article.

  To delete an article, simply move it to ‚Äòtrash‚Äô ---of course this will delete it
  in other mail clients as well. There is no return from trash.

  Emails can always be archieved ---never delete, maybe?

- =R, r=: Reply with sender's quoted text in place, or without but
  still visible in an adjacent buffer.
  - Likewise ~S W~ or ~S w~ to reply all, ‚Äòwide reply‚Äô, with or without quoted text.
  - ~C-c C-z~ Delete everything from current position till the end.
  - ~C-c C-e~ Replace selected region with ‚Äò[...]‚Äô; when omitting parts of quoted text.

- Press ~m~ to compose mail; or ~C-x m~ from anywhere in Emacs to do so.
  - ~C-c C-c~ to send the mail.
  - ~S D e~ to resend an article as new mail: Alter body, subject, etc, before
  - ~C-c C-f~ to forward mail.
    sending.

- ~C-c C-a~ to attach a file; it'll be embedded in the mail body as plaintext.
  - Press ~o~ on an attachment to save it locally.

*** Auto-completing mail addresses
In order to get going quickly, using [[https://github.com/redguardtoo/gmail2bbdb][gmail2bbdb]], let's convert our Gmail
contacts into a BBDB file ---the [[http://bbdb.sourceforge.net/][Insidious Big Brother Database]] is an
address-book application that we'll use for E-mail; if you want to use it as a
address-book application to keep track of contacts, notes, their organisation,
etc, then consider additionally installing [[https://github.com/emacs-helm/helm-bbdb][helm-bbdb]] which gives a nice menu
interface.

- From the [[https://www.google.com/contacts][Gmail Contacts page]], obtain a =contacts.vcf= file by clicking ‚ÄúMore ->
  Export -> vCard format -> Export‚Äù.
- Run command =M-x gmail2bbdb-import-file= and select =contacts.vcf=; a ~bbdb~ file
  will be created in my Dropbox folder.
- Press ~C-x m~ then begin typing a contact's name and you'll be queried about
  setting up BBDB, say yes.

#+begin_src emacs-lisp
(use-package gmail2bbdb
  :custom (gmail2bbdb-bbdb-file "~/Dropbox/bbdb"))

(use-package bbdb
 :demand t
 :after company ;; The ‚Äúcom‚Äùplete ‚Äúany‚Äùthig mode is set below in ¬ßProse
 :hook   (message-mode . bbdb-insinuate-gnus)
         (gnus-startup-hook . bbdb-insinuate-gnus)
 :custom (bbdb-file gmail2bbdb-bbdb-file)
         (bbdb-use-pop-up t)                        ;; allow popups for addresses
 :config (add-to-list 'company-backends 'company-bbdb))
#+end_src

Here is an [[http://emacs-fu.blogspot.com/2009/08/managing-e-mail-addresses-with-bbdb.html][emacs-fu]] article on managing e-mail addressed with bbdb.

*** Feeds to Blogs                                                 :Disabled:
One can easily subscribe to an RSS feed in Gnus: Just press ~G R~ in the group
buffer view, then follow the prompts. However, doing so programmatically is much
harder.  Below is my heartfelt attempt at doing so ---if you want a feed reader
in Emacs that ‚Äújust works‚Äù, then [[https://github.com/skeeto/elfeed][elfeed]] is the way to go. When all is said and
done, the code below had me reading Gnus implementations and led me to conclude
that /Gnus has a great key-based interface but a /poor programming interface/ ---or
maybe I need to actually read the manual instead of frantically consulting
source code.

My homemade hack to getting tagged feeds programmatically into Gnus.
#+begin_src emacs-lisp :tangle no
;; Always show Gnus items organised by topic.
(add-hook 'gnus-group-mode-hook 'gnus-topic-mode)

;; From Group view, press ^, then SPC on Gwene, then look for the site you want to follow.
;; If it's not there, add it via the web interface http://gwene.org/
(add-to-list 'gnus-secondary-select-methods '(nntp "news.gwene.org"))
;;
;; E.g., http://nullprogram.com/feed/ uses an Atom feed which Gnus does not
;; support natively.  But it can be found on Gwene.

(setq my/gnus-feeds
      ;; topic  title  url
      '(Emacs "C‚Äòest La ùíµ" https://cestlaz.github.io/rss.xml
        Emacs "Marcin Borkowski's Blog" http://mbork.pl?action=rss
        Emacs "Howardism" http://www.howardism.org/rss.xml
        Islam "Shia Islam Blogspot" http://welcometoshiaislam.blogspot.com/feeds/posts/default?alt=rss
        Cats "Hedonistic Learning" http://www.hedonisticlearning.com/rss.xml
        Cats "Functorial Blog"  https://blog.functorial.com/feed.rss
        Programming "Joel on Software" http://www.joelonsoftware.com/rss.xml
        Haskell "Lysxia's Blog"  https://blog.poisson.chat/rss.xml))

;; If fubared, then:
;; (ignore-errors (f-delete "~/News/" 'force) (f-delete "~/.newsrc.eld"))

;; Execute this after a Gnus buffer has been opened.
(progn
(use-package with-simulated-input)
(loop for (topic title url)
      in (-partition 3 my/gnus-feeds)
      ;; url & topic are symbols, make them strings.
      for url‚Ä≤   = (symbol-name url)
      for topic‚Ä≤ = (symbol-name topic)
      ;; Avoid spacing issues by using a Unicode ghost space ‚Äú¬†‚Äù.
      for title‚Ä≤ = (gnus-newsgroup-savable-name (s-replace " " "¬†" title))
      for input  = (format "C-SPC C-a %s RET RET" title‚Ä≤)
      do
      ; cl-letf* (((symbol-function 'insert) (lambda (x) nil))) ;; see the (undo) below.
      ;; Add the group
      (with-simulated-input input
        (gnus-group-make-rss-group url‚Ä≤))
      ;; Ensure it lives in the right topic category.
      (if (equal 'no-such-topic (alist-get topic gnus-topic-alist 'no-such-topic nil #'string=))
        (push (list topic‚Ä≤ title‚Ä≤) gnus-topic-alist) ;; make topic if it doesnt exist
      (setf (alist-get topic‚Ä≤ gnus-topic-alist 'no-such-topic nil #'string=)
            (cons title‚Ä≤ (alist-get topic gnus-topic-alist 'no-such-topic nil #'string=)))))
      ;; Acknowledgement
      (message "Now switch into the GNUS group buffer, and refresh the topics; i.e., t t."))

      ;; The previous command performs an insert, since it's intended to be interactively
      ;; used; let's undo the insert.
      ; (undo-only)

;; (setq gnus-permanently-visible-groups ".*")
;;
;; Show topic alphabetically? The topics list is rendered in reverse order.
;; (reverse (cl-sort gnus-topic-alist 'string-lessp :key 'car))
#+end_src

Ironically, I've decide that ‚Äúno, I do not want to see my blogs in Emacs‚Äù for
the same reasons I do not activelly use ~M-x eww~ to browse the web in Emacs: I
like seeing the colours, fonts, and math symbols that the authours have labored
over to producing quality content. Apparently, I'm shallow and I'm okay with it
---but not that shallow, since I'm constantly pushing Emacs which looks ugly by
default but it's unreasonably powerful.
** Hydra: Supply a prefix only once
Sometimes we have keybindings that share a common prefix, say ~C-c j~ and ~C-c k~,
and we invoke them in an arbitrary sequence, it would be nice to invoke the
shared prefix /only once/ thereby having:
| ~C-c j C-c j C-c k C-c k M-3 C-c j M-5 C-c k~ | ‚âà | ~C-c jjkk3j5k~ |

- The [[https://github.com/abo-abo/hydra#the-one-with-the-least-amount-of-code][‚Äúhydra-zoom‚Äù]] example from the documentation really showcases this utility.
- After the prefix is supplied, all extensions are shown in a minibuffer.

#+begin_src emacs-lisp
;; Invoke all possible key extensions having a common prefix by
;; supplying the prefix only once.
(use-package hydra)

;; The standard syntax:
;; (defhydra hydra-example (global-map "C-c v") ;; Prefix
;;   ;; List of triples (extension method description) )
#+end_src

From the [[https://github.com/abo-abo/hydra][Hydra]] repository is a ‚Äòdescription for poets‚Äô:
#+begin_quote
Once you summon the Hydra through the prefixed binding (the body + any one
head), all heads can be called in succession with only a short extension.

The Hydra is vanquished once Hercules, any binding that isn't the Hydra's head,
arrives. Note that Hercules, besides vanquishing the Hydra, will still serve his
original purpose, calling his proper command. This makes the Hydra very
seamless, it's like a minor mode that disables itself auto-magically.
#+end_quote

See [[#Taking-a-tour-of-one's-edits][Taking a tour of one's edits]] below for a small and useful example.

** Quickly pop-up a terminal, run a command, close it ---and zsh
/Pop up a terminal, do some work, then close it using the same command./

[[https://github.com/kyagi/shell-pop-el][Shell-pop]] uses only one key action to work: If the buffer exists, and we're in
it, then hide it; else jump to it; otherwise create it if it doesn't exit.  Use
universal arguments, e.g., ~C-u 5 C-t~, to have multiple shells and the same
universal arguments to pop those shells up, but ~C-t~ to pop them away.

#+begin_src emacs-lisp
(use-package shell-pop
  :custom
    ;; This binding toggles popping up a shell, or moving cursour to the shell pop-up.
    (shell-pop-universal-key "C-t")

    ;; Percentage for shell-buffer window size.
    (shell-pop-window-size 30)

    ;; Position of the popped buffer: top, bottom, left, right, full.
    (shell-pop-window-position "bottom")

    ;; Please use an awesome shell.
    (shell-pop-term-shell "/bin/zsh"))
#+end_src

Now that we have access to quick pop-up for a shell, let's get a pretty and
practical shell: [[https://www.howtogeek.com/362409/what-is-zsh-and-why-should-you-use-it-instead-of-bash/][zsh]] along with the [[https://ohmyz.sh/][Oh My Zsh]] community configurations give us:

1. ~brew install zsh~
2. ~sh -c "$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)"~

   This installs everything ^_^

#+begin_src emacs-lisp
;; Be default, Emacs please use zsh
;; E.g., M-x shell
(setq shell-file-name "/bin/zsh")
#+end_src

Out of the box, zsh comes with
- git support; the left side indicates which branch we're on and
  whether the repo is dirty, ‚úó.
- Recursive path expansion; e.g., ~/u/lo/b TAB~ expands to ~/usr/local/bin/~
- Over [[https://github.com/ohmyzsh/ohmyzsh/wiki/Plugins#apache2-macports][250+ Plugins]] and [[https://github.com/ohmyzsh/ohmyzsh/wiki/Themes][125+ Themes]] that are enabled by simply
  mentioning their name in the ~.zshrc~ file.

The defaults have been good enough for me, for now ---as all else is achieved
via Emacs ;-)

** Restarting Emacs ---Keeping buffers open across sessions?
Sometimes I wish to close then reopen Emacs; unsurprisingly someone's
thought of implementing that.
#+begin_src emacs-lisp
;; Provides only the command ‚Äúrestart-emacs‚Äù.
(use-package restart-emacs
  :demand t
  ;; Let's define an alias so there's no need to remember the order.
  :config (defalias 'emacs-restart #'restart-emacs))
#+end_src

The following is disabled. I found it a nuisance to have my files
open across sessions ---If I'm closing Emacs, it's for a good reason.
#+begin_example emacs-lisp
;; Keep open files open across sessions.
(desktop-save-mode 1)
(setq desktop-restore-eager 10)
#+end_example

Instead, let's try the following: When you visit a file, point goes to the last
place where it was when you previously visited the same file.
#+begin_src emacs-lisp
(setq-default save-place  t)
(setq save-place-file "~/.emacs.d/etc/saveplace")
#+end_src

** Automatic Backups
By default, Emacs saves backup files ---those ending in =~=--- in the current
directory, thereby cluttering it up. Let's place them in ~~/.emacs.d/backups~, in
case we need to look for a backup; moreover, let's keep old versions since
there's disk space to go around ---what am I going to do with 500gigs when nearly
all my ‚Äòsoftware‚Äô is textfiles interpreted within Emacs üòº

#+begin_src emacs-lisp
;; New location for backups.
(setq backup-directory-alist '(("." . "~/.emacs.d/backups")))

;; Silently delete execess backup versions
(setq delete-old-versions t)

;; Only keep the last 1000 backups of a file.
(setq kept-old-versions 1000)

;; Even version controlled files get to be backed up.
(setq vc-make-backup-files t)

;; Use version numbers for backup files.
(setq version-control t)
#+end_src

Why backups? Sometimes I may forget to submit a file, or edit, to my
version control system, and it'd be nice to be able to see a local
automatic backup. Whenever ‚ÄòI need space,‚Äô then I simply empty
the backup directory, if ever. That the backups are numbered is so sweet ^_^

Like package installations, my backups are not kept in any version control
system, like git; only locally.

Let's use an elementary diff system for backups.
#+begin_src emacs-lisp
(use-package backup-walker
  :commands backup-walker-start)
#+end_src

In a buffer that corresponds to a file, invoke ~backup-walker-start~ to see a
visual diff of changes /between/ versions.  By default, you see the changes
‚Äòbackwards‚Äô: Red means delete these things to get to the older version; i.e.,
the red ‚Äò-‚Äô are newer items.

Emacs only makes a backup the very first time a buffer is saved; I'd prefer
Emacs makes backups everytime I save! ---If I saved, that means I'm at an
important checkpoint, so please check what I have so far as a backup!
#+begin_src emacs-lisp
;; Make Emacs backup everytime I save

(defun my/force-backup-of-buffer ()
  "Lie to Emacs, telling it the curent buffer has yet to be backed up."
  (setq buffer-backed-up nil))

(add-hook 'before-save-hook  'my/force-backup-of-buffer)
#+end_src

It is intestesting to note that the above snippet could be modified to [[https://stackoverflow.com/a/6918217/3550444][make our
own backup system]], were Emacs lacked one, by having our function simply save
copies of our file ---on each save--- where the filename is augmented with a
timestamp.

- =diff-backup= compares a file with its backup or vice versa.

** Editor Documentation with Contextual Information
/Emacs is an extensible self-documenting editor!/

Let's use a helpful Emacs /documentation/ system that cleanly shows a lot of
contextual information ---then let's /extend/ that to work as we want it to:
~C-h o~ to describe the symbol at point.
#+begin_src emacs-lisp
(use-package helpful)

(defun my/describe-symbol (symbol)
  "A ‚ÄúC-h o‚Äù replacement using ‚Äúhelpful‚Äù:
   If there's a thing at point, offer that as default search item.

   If a prefix is provided, i.e., ‚ÄúC-u C-h o‚Äù then the built-in
   ‚Äúdescribe-symbol‚Äù command is used.

   ‚á® Pretty docstrings, with links and highlighting.
   ‚á® Source code of symbol.
   ‚á® Callers of function symbol.
   ‚á® Key bindings for function symbol.
   ‚á® Aliases.
   ‚á® Options to enable tracing, dissable, and forget/unbind the symbol!
  "
  (interactive "p")
  (let* ((thing (symbol-at-point))
         (val (completing-read
               (format "Describe symbol (default %s): " thing)
               (vconcat (list thing) obarray)
               (lambda (vv)
                 (cl-some (lambda (x) (funcall (nth 1 x) vv))
                          describe-symbol-backends))
               t nil nil))
         (it (intern val)))
    (cond
     (current-prefix-arg (funcall #'describe-symbol it))
     ((or (functionp it) (macrop it) (commandp it)) (helpful-callable it))
     (t (helpful-symbol it)))))

;; Keybindings.
(global-set-key (kbd "C-h o") #'my/describe-symbol)
(global-set-key (kbd "C-h k") #'helpful-key)
#+end_src

I like [[https://github.com/Wilfred/helpful][helpful]] and wanted it to have the same behaviour as ~C-h o~, which
~helpful-at-point~ does not achieve. The incantation above makes ~C-h o~ use ~helpful~
in that if the cursor is on a symbol, then it is offered to the user as a
default search item for help, otherwise a plain search box for help
appears. Using a universal argument lets us drop to the built-in help command.
* Cosmetics
Upon startup, we want to be greeted with a useful, yet unobtrusive, message
briefly detailing major system details. Moreover, the bottom-most area of
the screen should display batter life, data, & time. Likewise, we may have
a casual file explorer ---primarily to show-off to newcomers, since great
functionality is found with ~M-x dired~.

** Startup message: Emacs & Org versions
Let's always welcome ourselves when Emacs begins with a helpful message.  For
example, which user account is running and what are the version numbers of our
primary tools.

#+begin_src emacs-lisp
;; Silence the usual message: Get more info using the about page via C-h C-a.
(setq inhibit-startup-message t)

(defun display-startup-echo-area-message ()
  "The message that is shown after ‚Äòuser-init-file‚Äô is loaded."
  (message
      (concat "Welcome "      user-full-name
              "! Emacs "      emacs-version
              "; Org-mode "   org-version
              "; System "     (system-name)
              "; Time "       (emacs-init-time))))
#+end_src
Now my startup message is,
#+begin_src emacs-lisp
;; Welcome Musa Al-hassy! Emacs 26.1; Org-mode 9.3; System alhassy-air.local
#+end_src
Let's change the Emacs frame to mention the name of the buffer in focus,
as well as a nice ‚Äòmotto‚Äô:
#+begin_src emacs-lisp
;; Keep self motivated!
(setq frame-title-format '("" "%b - Living The Dream (‚Ä¢ÃÄ·¥ó‚Ä¢ÃÅ)Ÿà"))
#+end_src
** My to-do list: The initial buffer when Emacs opens up
I almost always have Emacs open; I don't need a dashboard, but would like to see
my to-do list and my init file, side-by-side.
#+begin_src emacs-lisp
(find-file "~/Dropbox/todo.org")
(split-window-right)			  ;; C-x 3
(other-window 1)                              ;; C-x 0
(let ((enable-local-variables :all)           ;; Load *all* locals.
      (org-confirm-babel-evaluate nil))       ;; Eval *all* blocks.
  (find-file "~/.emacs.d/init.org"))
#+end_src

There is the neat-looking [[https://github.com/emacs-dashboard/emacs-dashboard][emacs-dashboard]] package that provides an extensbile
yet minimalist splash screen showing recent files, projects, and bookmarks.

** Exquisite Themes
Emacs' default theme leaves much to be desired:
It does not look sleek and shiny, which usually
leaves first-timers with a poor, shallow, impression of the system.

Below we install a few themes that make Emacs look exquisite.
We cycle between the chosen themes with ~C-x t~.

- ~M-x load-theme RET TAB~ shows all themes, including built-in ones,
  that may be loaded.
- Loading multiple themes results in their pallets mixed.
  - ~M-x disable-theme~ to remove a theme from the current pallet.

#+begin_src emacs-lisp
;; Treat all themes as safe; no query before use.
(setf custom-safe-themes t)

;; Nice looking themes ^_^
(use-package solarized-theme)
(use-package doom-themes)
(use-package spacemacs-common
  :ensure spacemacs-theme)
#+end_src

- The [[https://github.com/hlissner/emacs-doom-themes/tree/screenshots][Doom Themes]] also look rather appealing.
- A showcase of many themes can be found [[https://emacsthemes.com/][here]].

#+begin_src emacs-lisp
;; Infinite list of my commonly used themes.
(setq my/themes '(doom-solarized-light doom-vibrant spacemacs-light))
(setcdr (last my/themes) my/themes)
#+end_src

‚ÄúC-x t‚Äù to toggle between the personal themes.
#+begin_src emacs-lisp
(cl-defun my/disable-all-themes (&key (new-theme (pop my/themes)))
  "Disable all themes and load NEW-THEME, which defaults from ‚Äòmy/themes‚Äô."
  (interactive)
  (dolist (œÑ custom-enabled-themes)
    (disable-theme œÑ))
  (when new-theme (load-theme new-theme)))

(defalias 'my/toggle-theme #' my/disable-all-themes)
(global-set-key "\C-x\ t" 'my/toggle-theme)
(my/toggle-theme)
#+end_src

Apparently, there's already a package that accomplishes these goals and more:
[[https://github.com/myTerminal/theme-looper][theme-looper]]. I may switch to it, but for now my simple function above is
slightly informative, to me at least, about how themes work and it does what I
want.

** A sleek & informative mode line
The ‚Äòmodeline‚Äô is a part near the bottom of Emacs that gives information about
the current mode, as well as other matters ---such as time & date, for example.

Let's have it also show remaining battery life, coloured green if charging
and coloured yellow otherwise. It is important to note that
this package is no longer maintained. It works on my machine.
#+begin_src emacs-lisp
(setq display-time-day-and-date t)
(display-time)
;; (display-battery-mode -1)
;; Nope; let's use a fancy indicator ‚Ä¶
(use-package fancy-battery
  :diminish
  :custom (fancy-battery-show-percentage  t)
          (battery-update-interval       15)
  :config (fancy-battery-mode))
#+end_src

Likewise, let's have the modeline display column numbers, but not line numbers.
Instead, let's have line numbers on the side of the buffer; moreover let's have
a uniform width for displaying line numbers, rather than having the width grow
as necessary.
#+begin_src emacs-lisp
;; Following two taken care of in the spaceline package, below.
;; (column-number-mode                 t)
;; (line-number-mode                   t)
(setq display-line-numbers-width-start t)
(global-display-line-numbers-mode      t)
#+end_src

I may not use the spacemacs [[https://www.emacswiki.org/emacs/StarterKits][starter kit]], since I find spacemacs to ‚Äúhide things‚Äù
from me ---whereas Emacs ‚Äúencourages‚Äù me to learn more---, however it is a
configuration and I enjoy reading Emacs configs in order to improve my own
setup. From Spacemacs I've adopted Helm for list completion, its sleek light &
dark themes, and its modified powerline setup.
#+begin_src emacs-lisp
;; When using helm & info & default, mode line looks prettier.
(use-package spaceline
  :custom (spaceline-buffer-encoding-abbrev-p nil)
          (spaceline-line-column-p t) ;; Show ‚Äúline-number : column-number‚Äù in modeline.
          (powerline-default-separator 'arrow)
  :config (require 'spaceline-config)
          (spaceline-helm-mode)
          (spaceline-info-mode)
          (spaceline-emacs-theme))
#+end_src

Other separators ---of modeline information--- that I've considered include
~'brace~ instead of an arrow, and ~'contour, 'chamfer, 'wave, 'zigzag~ which look
like browser tabs that are curved, boxed, wavy, or in the style of driftwood.
** Never lose the cursor
Let's have the entire line containing the cursour be slightly highlighted.
#+begin_src emacs-lisp
;; Make it very easy to see the line with the cursor.
(global-hl-line-mode t)
#+end_src

Moreover, we reduce the mental strain of locating the cursour when navigation happens:
When we switch windows or scroll, for example, we get a wave of light near the cursor.
#+begin_src emacs-lisp
(use-package beacon
  :diminish
  :config (setq beacon-color "#666600")
  :hook   ((org-mode text-mode) . beacon-mode))
#+end_src

** Dimming Unused Windows
Let's dim windows, and even the whole Emacs frame, when not in use.
#+begin_src emacs-lisp
(use-package dimmer
  :config (dimmer-mode))
#+end_src

A more ‚Äòfine-grained‚Äô [[https://github.com/larstvei/Focus][tool]] dims all text except the ‚Äòparagraph‚Äô you're working
on. It's nifty, but not for me.

** Buffer names are necessarily injective
By default when multiple files sharing the same name are opened, say for
comparison from different directories, their buffers are named uniquely by
having the format ‚Äú‚ü®file-name‚ü© <ùìÉ>‚Äù, for numbers ùìÉ. It'd be more helpful
to have the buffer names reflect their location.
#+begin_src emacs-lisp
;; Note that ‚Äòuniquify‚Äô is builtin.
(require 'uniquify)
(setq uniquify-separator "/"               ;; The separator in buffer names.
      uniquify-buffer-name-style 'forward) ;; names/in/this/style
#+end_src

Note that this does not affect cloning buffers, ~C-x 4 c~.

( A function /f/ is /injective/ precisely when it's /distinction-preserving/; i.e.,
  /x ‚â† y ‚â° f x ‚â† f y/. We can tell whether two things are the same or not, by
  ‚Äòzooming in‚Äô on their particular property ‚Äòf‚Äô, which may be easier to compare.
  E.g., object IDs, hashcodes, unique keys in database tables. )

( Why am I bringing this up? I like math and seldom get to use it; so why not! )

** Flashing when something goes wrong ---no blinking
Make top and bottom of screen flash when something unexpected happens thereby
observing a warning message in the minibuffer. E.g., C-g, or calling an unbound
key sequence, or misspelling a word.
#+begin_src emacs-lisp
(setq visible-bell 1)
#+end_src
Enable flashing mode-line on errors.  On MacOS, this shows a caution symbol ^_^

A blinking cursor rushes me to type; let's slow down.
‚Ä¶ Recentely I'm thinking that a blinking cursours prompts me to continue
upwards and onwards.
#+begin_src emacs-lisp
(blink-cursor-mode 1)
#+end_src

** Hiding Scrollbar, tool bar, and menu
As a laptop user, screen space is important, so let's remove rarely used visual
items.
#+begin_src emacs-lisp
(tool-bar-mode   -1)  ;; No large icons please
(scroll-bar-mode -1)  ;; No visual indicator please
(menu-bar-mode   -1)  ;; The Mac OS top pane has menu options
#+end_src

** Highlight & complete parenthesis pair when cursor is near ;-)
Highlight matching ‚Äòparenthesis‚Äô when near one of them.
#+begin_src emacs-lisp
(setq show-paren-delay  0)
(setq show-paren-style 'mixed)
(show-paren-mode)
#+end_src

Colour parens, and other delimiters, depending on their depth.
Very useful for parens heavy languages like Lisp.
#+begin_src emacs-lisp
(use-package rainbow-delimiters
  :disabled
  :hook ((org-mode prog-mode text-mode) . rainbow-delimiters-mode))
#+end_src

For example:
#+begin_src emacs-lisp :tangle no
(blue (purple (forest (green (yellow (blue))))))
#+end_src

There is a powerful package called ‚Äòsmartparens‚Äô for working with pair-able
characters, but I've found it to be too much for my uses. Instead I'll utilise
the lightweight package ~electric~, which Emacs provides out of the box.
#+begin_src emacs-lisp
(electric-pair-mode 1)
#+end_src
It supports, by default, ACSII pairs ~{}, [], ()~ and Unicode ~‚Äò‚Äô, ‚Äú‚Äù, ‚ü™‚ü´, ‚ü®‚ü©~.

When writing Lisp, it is annoyong to have ‚Äò<‚Äô and ‚Äò>‚Äô be completed
/and/ considered as pairs.  Let's disassociate them from both notions.
#+begin_src emacs-lisp
;; The ‚Äò<‚Äô and ‚Äò>‚Äô are not ‚Äòparenthesis‚Äô, so give them no compleition.
(setq electric-pair-inhibit-predicate
      (lambda (c)
        (or (member c '(?< ?> ?~)) (electric-pair-default-inhibit c))))

;; Treat ‚Äò<‚Äô and ‚Äò>‚Äô as if they were words, instead of ‚Äòparenthesis‚Äô.
(modify-syntax-entry ?< "w<")
(modify-syntax-entry ?> "w>")
#+end_src

*Adding Org-emphasise markers for pair completion ---Disabled.*

Let's add the org-emphasises markers: If we select a word then press =*=, it
becomes bold; likewise for ~/~ for emphasise.
#+begin_src emacs-lisp :tangle no
(setq electric-pair-pairs
         '((?~ . ?~)
           (?* . ?*)
           (?/ . ?/)))

;; Let's also, for example, avoid obtaining double ‚Äò~‚Äô and ‚Äò/‚Äô when searching for a file.

;; Disable pairs when entering minibuffer
(add-hook 'minibuffer-setup-hook (lambda () (electric-pair-mode 0)))

;; Renable pairs when existing minibuffer
(add-hook 'minibuffer-exit-hook (lambda () (electric-pair-mode 1)))
#+end_src

I use ‚Äò~‚Äô and ‚Äò/‚Äô too much during file navigation, and ‚Äò*‚Äô when marking numerous
Org headers, for which the ‚Äòcompleted closing pair‚Äô must tiresomely be deleted.
** Neotree: Directory Tree Listing
We open a nifty file manager upon startup.
#+begin_src emacs-lisp
;; Sidebar for project file navigation
(use-package neotree
  :config (global-set-key "\C-x\ d" 'neotree-toggle)
          (setq neo-theme 'icons)) ;; Uses all-the-icons from ¬ß Booting Up

;; Open it up upon startup.
;; (neotree-toggle)
#+end_src
By default ~C-x d~ invokes ~dired~, but I prefer ~neotree~ for file
management.

‚ü® Edit: As a naive user, this is what I thought; yet a year later,
                I've almost never used neotree. ‚ü©

Useful navigational commands include
- ~U~ to go up a directory.
- ~C-c C-c~ to change directory focus; ~C-C c~ to type the directory out.
- ~?~ or ~h~ to get help and ~q~ to quit.

As always, to go to the neotree pane when it's the only other window,
execute ~C-x o~.

I /rarely/ make use of this feature; company mode & Helm together quickly provide
an automatic replacement for nearly all of my uses.

- Reminiscent of GUI file managers is [[https://github.com/ralesi/ranger.el#features][ranger]]; e.g., it has multi-column
  display of parent directories along with a file preview mechanism.

** Tabs                                                            :Disabled:
I really like my Helm-supported ~C-x b~, but the visial appeal of a [[https://github.com/manateelazycat/awesome-tab][tab bar]] for Emacs
is interesting. Let's try it out and see how long this lasts ---it may be like Neotree:
Something cute to show to others, but not as fast as the keyboard.

#+begin_src emacs-lisp
(use-package awesome-tab
  :disabled
  :quelpa (awesome-tab :fetcher git :url "https://github.com/manateelazycat/awesome-tab.git")
  :config (awesome-tab-mode t))

;; Show me /all/ the tabs at once, in one group.
(defun awesome-tab-buffer-groups ()
  (list (awesome-tab-get-group-name (current-buffer))))
#+end_src

It's been less than three days and I've found this utility to be unhelpful, to me anyhow.

An alternative is [[https://github.com/ema2159/centaur-tabs][centaur-tabs.]]

** Window resizing using the golden ratio                          :Disabled:
Let's load the following package, which automatically resizes windows so that
the window containing the cursor is the largest, according to the golden ratio.
Consequently, the window we're working with is nice and large yet the other windows
are still readable.

#+begin_src emacs-lisp
(use-package golden-ratio
  :disabled
  :diminish golden-ratio-mode
  :init (golden-ratio-mode 1))
#+end_src

After some time this got a bit annoying and I'm no longer  using this.

** Persistent Scratch Buffer
The ~*scratch*~ buffer is a nice playground for temporary data or experiments.

However, by default its contents are not saved --which may be an issue if we
have not relocated our playthings to their appropriate files. Whence let's save
& restore the scratch buffer by default.
#+begin_src emacs-lisp
(use-package persistent-scratch
  ;; In this mode, the usual save key saves to the underlying persistent file.
  :bind (:map persistent-scratch-mode-map
              ("C-x C-s" . persistent-scratch-save)))
#+end_src

We might accidentally close this buffer, so we could utilise the following.
#+begin_src emacs-lisp
(defun scratch ()
   "Recreate the scratch buffer, loading any persistent state."
   (interactive)
   (switch-to-buffer-other-window (get-buffer-create "*scratch*"))
   (condition-case nil (persistent-scratch-restore) (insert initial-scratch-message))
   (org-mode)
   (persistent-scratch-mode)
   (persistent-scratch-autosave-mode 1))

;; This doubles as a quick way to avoid the common formula: C-x b RET *scratch*

;; Upon startup, close the default scratch buffer and open one as specfied above
(ignore-errors (kill-buffer "*scratch*") (scratch))
#+end_src

I use Org-mode often, so that's how I want things to appear.
#+begin_src emacs-lisp
(setq initial-scratch-message (concat
  "#+Title: Persistent Scratch Buffer"
  "\n#\n# Welcome! This‚Äô a place for trying things out."
  "\n#\n# ‚ü® ‚ÄòC-x C-s‚Äô here saves to ~/.emacs.d/.persistent-scratch ‚ü© \n\n"))
#+end_src

* Prose
Emacs can be setup with a spellchecker and other expected features of a word processing tool
---however these features apply Emacs-wide since nearly everything is
essentially text (‚Ä¢ÃÄ·¥ó‚Ä¢ÃÅ)Ÿà

Let's start off by cleaning-up any accidental trailing whitespace and in other
places upon save.
#+begin_src emacs-lisp
(add-hook 'before-save-hook 'whitespace-cleanup)
#+end_src

- Org-mode is a writer's best friend; it's large enough to deserve its own sections.
- See [[http://ergoemacs.org/emacs/whitespace-mode.html][here]] for making whitespace visible; including spaces, tabs, and newlines

** Fill-mode ---Word Wrapping
In fill mode, when you type past the end of a line, Emacs automatically starts a
new line, cleverly formatting paragraphs. This is a powerful form of ‚Äúword
wrap‚Äù.

#+begin_src emacs-lisp
(setq-default fill-column 80          ;; Let's avoid going over 80 columns
              truncate-lines nil      ;; I never want to scroll horizontally
              indent-tabs-mode nil)   ;; Use spaces instead of tabs
#+end_src

Certain variables are sensibly local to a buffer, and so ~setq~ only alters their
value for one buffer. Using ~setq-default~ we change a variable's default value,
in every buffer.

#+begin_src emacs-lisp
;; Wrap long lines when editing text
(add-hook 'text-mode-hook 'turn-on-auto-fill)
(add-hook 'org-mode-hook 'turn-on-auto-fill)

;; Do not show the ‚ÄúFill‚Äù indicator in the mode line.
(diminish 'auto-fill-function)
#+end_src

We may press ~M-q~ to cleverly redistribute the line breaks within any paragraph,
thereby making it look better. With a prefix argument, it justifies it as well
---i.e., pads extra white space to make the paragraph appear rectangular.

Note that ~M-o M-s~ centres a line of text ;-) Fun stuff!

** Word Completion
Let's enable [[https://company-mode.github.io/][‚Äúcomplete anything‚Äù mode]] ---it ought to start in half a second and
only need two characters to get going, which means word suggestions are provided
and so I need only type partial words then tab to get the full word!
#+begin_src emacs-lisp
(use-package company
  :diminish
  :config
  (global-company-mode 1)
  (setq ;; Only 2 letters required for completion to activate.
        company-minimum-prefix-length 2

        ;; Search other buffers for compleition candidates
        company-dabbrev-other-buffers t
        company-dabbrev-code-other-buffers t

        ;; Allow (lengthy) numbers to be eligible for completion.
        company-complete-number t

        ;; M-‚ü™num‚ü´ to select an option according to its number.
        company-show-numbers t

        ;; Edge of the completion list cycles around.
        company-selection-wrap-around t

        ;; Do not downcase completions by default.
        company-dabbrev-downcase nil

        ;; Even if I write something with the ‚Äòwrong‚Äô case,
        ;; provide the ‚Äòcorrect‚Äô casing.
        company-dabbrev-ignore-case t

        ;; Immediately activate completion.
        company-idle-delay 0))

;; It's so fast that we don't need a key-binding!
;; (global-set-key (kbd "C-c h") 'company-complete)
#+end_src
Note that ~M-/~ goes through a sequence of completions.  Besides the
arrow keys, we can also use ~C-~ or ~M-~ with ~n, p~ to navigate the options. Note
that [[https://github.com/company-mode/company-mode/issues/360][by default]] company mode does not support completion for phrases containing
hyphens ---this can be altered, if desired.

Besides boring word completion, let's add support for [[https://github.com/dunn/company-emoji][emojis]].
#+begin_src emacs-lisp
(use-package company-emoji
  :config (add-to-list 'company-backends 'company-emoji))
#+end_src

For example: ü•û üíª üêµ ‚úâÔ∏èüòâ üê¨ üåµ.

‚û°Ô∏èOn a new line, write ~:~ then any letter to have a tool-tip appear.
All emoji names are lowercase. ‚óÄ

The libraries ~emojify~ and ~emojify-logos~ provides cool items like =:haskell: :emacs:
:org: :ruby: :python:=.
Unfortunately they do not easily export to html with org-mode, so I'm not using them.

** Fix spelling as you type ---thesaurus & dictionary too!
I would like to check spelling on the fly.
- ~C-;~ :: Cycle through corrections for word at point.
- ~M-$~ :: Check and correct spelling of the word at point
- ~M-x ispell-change-dictionary RET TAB~ :: To see what dictionaries are available.

~flyspell-prog-mode~ enables spell checking for programming by only considering
comments and strings.

#+begin_src emacs-lisp
(use-package flyspell
  :diminish
  :hook ((prog-mode . flyspell-prog-mode)
         (text-mode . flyspell-mode)))
#+end_src

Enabling fly-spell for text-mode enables it for org and latex modes since they
derive from text-mode.

Flyspell needs a spell checking tool, which is not included in Emacs.  We
install ~aspell~ spell checker using, say, homebrew via ~brew install aspell~.  Note
that Emacs' ~ispell~ is the interface to such a command line spelling utility.

#+begin_src emacs-lisp
(setq ispell-program-name "/usr/local/bin/aspell")
(setq ispell-dictionary "en_GB") ;; set the default dictionary
#+end_src

[Disabled] Allow spelling support for CamlCase words like ‚ÄúEmacsIsCool‚Äù.
#+begin_src emacs-lisp :tangle no
(setq  ispell-extra-args '("--sug-mode=ultra"
                            "--run-together"
                            "--run-together-limit=5"
                            "--run-together-min=2"))
#+end_src

Let us select a correct spelling merely by clicking on a word
---for the rare days I have a mouse.
#+begin_src emacs-lisp
(eval-after-load "flyspell"
  ' (progn
     (define-key flyspell-mouse-map [down-mouse-3] #'flyspell-correct-word)
     (define-key flyspell-mouse-map [mouse-3] #'undefined)))
#+end_src

Colour incorrect works; default is an underline.
#+begin_src emacs-lisp
(global-font-lock-mode t)
(custom-set-faces '(flyspell-incorrect ((t (:inverse-video t)))))
#+end_src

Finally, save to user dictionary without asking:
#+begin_src emacs-lisp
(setq ispell-silently-savep t)
#+end_src

Let's keep track of my personal word set by having it be in my version controlled
.emacs directory. [[http://aspell.net/man-html/Format-of-the-Personal-and-Replacement-Dictionaries.html][Note]] that the default location is ~~/.[i|a]spell.DICT~ for
a specified dictionary ~DICT~.
#+begin_src emacs-lisp
(setq ispell-personal-dictionary "~/.emacs.d/.aspell.en.pws")
#+end_src

Nowadays, I very rarely write non-literate programs, but if I do
I'd like to check spelling only in comments/strings. E.g.,
#+begin_src emacs-lisp
(add-hook          'c-mode-hook 'flyspell-prog-mode)
(add-hook 'emacs-lisp-mode-hook 'flyspell-prog-mode)
#+end_src

Use the thesaurus Emacs frontend [[https://github.com/hpdeifel/synosaurus][Synosaurus]] to avoid unwarranted repetition.
#+begin_src emacs-lisp
(use-package synosaurus
  :diminish synosaurus-mode
  :init    (synosaurus-mode)
  :config  (setq synosaurus-choose-method 'popup) ;; 'ido is default.
           (global-set-key (kbd "M-#") 'synosaurus-choose-and-replace))
#+end_src
The thesaurus is powered by the Wordnet ~wn~ tool, which can be invoked without an
internet connection!
#+begin_src emacs-lisp
;; (shell-command "brew cask install xquartz &") ;; Dependency
;; (shell-command "brew install wordnet &")
#+end_src

Let's use Wordnet as a dictionary via the [[https://github.com/gromnitsky/wordnut][wordnut]] package.
#+begin_src emacs-lisp
(use-package wordnut
 :bind ("M-!" . wordnut-lookup-current-word))

;; Use M-& for async shell commands.
#+end_src
Use ~M-‚Üë,‚Üì~ to navigate dictionary results, and ~wordnut-search~ for a new search.

An alternative to =wordnut= is to use the lightweight ~define-word~ package; which I
think is not ideal since it provides way less information.
** Touch Typing
Use this game to help you learn to spell words that you're having trouble with;
e.g., I have a file ~~/Dropbox/spelling.txt~ with words I have trouble spelling,
which I open then run ~M-x typing-of-emacs~ in order to improve spelling said
words.
#+begin_src emacs-lisp :tangle no
;; The Typing Of Emacs, a game.
(use-package typing-of-emacs
  :quelpa (typing :fetcher wiki :url "https://www.emacswiki.org/emacs/typing.el"))
#+end_src

Practice touch typing using [[https://github.com/hagleitn/speed-type][speed-type]].
#+begin_src emacs-lisp
(use-package speed-type)
#+end_src
Running ~M-x speed-type-region~ on a region of text, or ~M-x speed-type-buffer~ on a
whole buffer, or just ~M-x speed-type-text~ will produce the selected region, buffer,
or random text for practice. The timer begins when the first key is pressed
and stats are shown when the last letter is entered.

Other typing resources include:
- [[https://www.emacswiki.org/emacs/TypingOfEmacs][Typing of Emacs]] ---an Emacs alternative to speed type, possibly more engaging.
- [[https://alternativeto.net/software/klavaro/][Klavaro]] ---a GUI based yet language-independent typing tutor.
  - I'm enjoying this tool in getting started with Arabic typing.
- [[https://typing.io/][Typing.io]] is a tutor for coders: Lessons are based on open source code, such
  some XMonad written in Haskell or Linux written in C.
- [[https://www.gnu.org/software/gtypist/index.html#downloading][GNU Typist]] ---which is interactive in the terminal, so not ideal in Emacs--,

To assist in language learning, it may be nice to have an Emacs
[[https://github.com/atykhonov/google-translate][interface]] to Google translate ---e.g., invoke ~google-translate-at-point~.
#+begin_src emacs-lisp
(use-package google-translate
 :config
   (global-set-key "\C-ct" 'google-translate-at-point))
#+end_src

Select the following then ~C-c t~,
#+begin_quote
Hey buddy, what're you up to?
#+end_quote
Then /detect language/ then /Arabic/ to obtain:
#+begin_quote
ŸÖÿ±ÿ≠ÿ®ÿßŸã Ÿäÿß ÿµÿØŸäŸÇŸä ÿå ŸÖÿßÿ∞ÿß ÿ™ŸÅÿπŸÑÿü
#+end_quote
Neato üò≤

** Using a Grammar & Style Checker
Let's install [[https://github.com/mhayashi1120/Emacs-langtool][a grammar and style checker]].
We get the offline tool from the bottom of the [[https://languagetool.org/][LanguageTool]] website, then relocate it
as follows.
#+begin_src emacs-lisp
(use-package langtool
 :config
  (setq langtool-language-tool-jar
     "~/Applications/LanguageTool-4.5/languagetool-commandline.jar")
)
#+end_src

Now we can run ~langtool-check~ on the subsequent grammatically incorrect
text ---which is from the LanguageTool website--- which colours errors in red,
when we click on them we get the reason why; then we may invoke
~langtool-correct-buffer~ to quickly use the suggestions to fix each correction,
and finally invoke ~langtool-check-done~ to stop any remaining red colouring.

#+begin_example org
LanguageTool offers spell and grammar checking. Just paste your text here
and click the 'Check Text' button. Click the colored phrases for details
on potential errors. or use this text too see an few of of the problems
that LanguageTool can detecd. What do you thinks of grammar checkers?
Please not that they are not perfect. Style issues get a blue marker:
It's 5 P.M. in the afternoon. The weather was nice on Thursday, 27 June 2017
--uh oh, that's the wrong date ;-)
#+end_example

By looking around the source code, I can do all three stages smoothly (‚Ä¢ÃÄ·¥ó‚Ä¢ÃÅ)Ÿà
#+begin_src emacs-lisp
;; Quickly check, correct, then clean up /region/ with M-^

(add-hook 'langtool-error-exists-hook
  (lambda ()
     (langtool-correct-buffer)
     (langtool-check-done)))

(global-set-key "\M-^"
                (lambda ()
                  (interactive)
                  (message "Grammar checking begun ...")
                  (langtool-check)))
#+end_src

The checking command is silent, we added a bit of comforting acknowledgement to the user.

** Lightweight Prose Proofchecking
Let's [[https://github.com/bnbeckwith/writegood-mode][write good]]!

#+begin_src emacs-lisp
(use-package writegood-mode
  ;; Load this whenver I'm composing prose.
  :hook (text-mode org-mode)
  ;; Don't show me the ‚ÄúWg‚Äù marker in the mode line
  :diminish
  ;; Some additional weasel words.
  :config
  (--map (push it writegood-weasel-words)
         '("some" "simple" "simply" "easy" "often" "easily" "probably"
           "clearly"               ;; Is the premise undeniably true?
           "experience shows"      ;; Whose? What kind? How does it do so?
           "may have"              ;; It may also have not!
           "it turns out that")))  ;; How does it turn out so?
           ;; ‚ÜØ What is the evidence of highighted phrase? ‚ÜØ
#+end_src

Inspired by Matt Might's [[http://matt.might.net/articles/shell-scripts-for-passive-voice-weasel-words-duplicates/][3 shell scripts to improve your writing, or
"My Ph.D. advisor rewrote himself in bash"]], this Emacs interface
emphasises, via underline, the following weaknesses in writing ---so
that I can fix them or decide that they are appropriate for the
scenario.

Sentences that cut out the following problems may become stronger
---by being more terse or precise.

- Weasel Words ::
     Phrases that sound good without conveying information;
     such as vague precision or subjective phrases.

     E.g., /a number of, surprisingly, very close/.

     It's okay not to have exact details, but rather than ‚ÄúI don't know‚Äù
     explain why not and what the next steps will be.

- Passive Voice ::
     Phrases wherein interest is in the object experiencing an action,
     rather than the subject that performs the action.

  - Bad: The house /was built by/ my father.
  - Good: My father /built/ this house.

  Likewise, including relevant or explanatory information as in ‚ÄúX
  guarantees Y‚Äù is an improvement over ‚ÄúY is guaranteed‚Äù.

  Sometimes the subject really is irrelevant, such as
  ‚ÄúWe did X‚Äù whereas ‚ÄúX happened‚Äù suffices.

  üëç If the relevant subject is unclear and, also, the text reads
  better in the active, then change a phrase.

- Duplicated Words :: Occurrences of, say, ‚Äúthe the‚Äù.

     Harder to catch manually, but easier mechanically ;-)

** Placeholder Text ---For Learning & Experimenting
When learning about Emacs formatting commands, such as zap-to-char ~M-z~
or transpose ~M-t~, it's best to have filler text ---even better when
it's automatically generated instead of typing it out ourselves. The
following will give us a series of commands ~lorem-ipsum-insert-‚ãØ~ for
inserting lists, sentences, paragraphs and using a prefix argument,
with ~C-u~, we can request to generate any number of them.

#+begin_src emacs-lisp
(use-package lorem-ipsum)
#+end_src

‚ÄòLorem‚Äô is not a word itself, but it comes from the Latin ‚ÄòDolorem Ipsum‚Äô
which means ‚Äúpain in and of itself‚Äù.

See this [[https://github.com/alhassy/emacs.d/blob/master/CheatSheet.pdf][Emacs Cheat Sheet]] to try out the textual navigation and formatting
bindings on lorem ipsum, gibberish text.

** Some text to make us smile
The  [[https://github.com/davep/dad-joke.el][dad-joke]] queries [[https://icanhazdadjoke.com][https://icanhazdadjoke.com]] to bring us some funny.
#+begin_src emacs-lisp
(use-package dad-joke
  :config (defun dad-joke () (interactive) (insert (dad-joke-get))))
#+end_src

For example, ~M-x dad-joke~ now inserts:
#+begin_quote
What are the strongest days of the week? Saturday and Sunday...the rest are
weekdays.
#+end_quote

** Unicode Input via Agda Input
[[https://mazzo.li/posts/AgdaSort.html][Agda]] is one of my favourite languages, it's like Haskell on steroids.  Let's set
it up for the main sake of its Unicode input ---you may do likewise using TeX
input.  ( [[https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/][The Absolute Minimum Every Software Developer Absolutely, Positively
Must Know About Unicode and Character Sets (No Excuses!)]] )

Executing ~agda-mode setup~ appends the following text to the ~.emacs~ file.
Let's put it here ourselves.
#+begin_src emacs-lisp
(load-file (let ((coding-system-for-read 'utf-8))
                (shell-command-to-string "/usr/local/bin/agda-mode locate")))
#+end_src

I almost always want the ~agda-mode~ input method ---it's like the TeX method, but better.
#+begin_src emacs-lisp
(require 'agda-input)
(setq default-input-method "Agda")
(toggle-input-method)  ;; C-\
#+end_src

#+begin_quote
Unicode doesn't intend to cover things that are achievable with markup, so only
a limited subset of the alphabet is available as subscript; but all is available
as superscript, except ‚Äòq‚Äô.

‚Çê‚Çë‚Çï·µ¢‚±º‚Çñ‚Çó‚Çò‚Çô‚Çí‚Çö·µ£‚Çõ‚Çú·µ§·µ•‚Çì
‚Å∞ ¬π ¬≤ ¬≥ ‚Å¥ ‚Åµ ‚Å∂ ‚Å∑ ‚Å∏ ‚Åπ ‚Å∫ ‚Åª ‚Åº ‚ÅΩ ‚Åæ ‚ÇÄ ‚ÇÅ ‚ÇÇ ‚ÇÉ ‚ÇÑ ‚ÇÖ ‚ÇÜ ‚Çá ‚Çà ‚Çâ ‚Çä ‚Çã ‚Çå ‚Çç ‚Çé
·µÉ ·µá ·∂ú ·µà ·µâ ·∂† ·µç  ∞ ‚Å±  ≤ ·µè À° ·µê ‚Åø ·µí ·µñ  ≥ À¢ ·µó ·µò ·µõ  ∑ À£  ∏ ·∂ª
·¥¨ ·¥Æ ·¥∞ ·¥± ·¥≥ ·¥¥ ·¥µ ·¥∂ ·¥∑ ·¥∏ ·¥π ·¥∫ ·¥º ·¥æ ·¥ø ·µÄ ·µÅ ‚±Ω ·µÇ
·µÖ ·µù ·µû ·µü ·µã ·∂ø ·∂• ·∂≤ ·µ† ·µ° ·µ¶ ·µß ·µ® ·µ© ·µ™

~brew cask install font-symbola~
‚áí Includes fonts for subscripts; e.g., ‚Çê‚Çô‚Çë‚Çï·µ¢‚±º‚Çñ‚Çó‚Çò‚Çô‚Çí‚Çö‚Çú‚Çõ
#+end_quote

Below are my personal Agda input symbol translations;
e.g., ~\set ‚Üí ùíÆ‚ÑØùìâ~. Note that we could give a symbol new Agda TeX binding
interactively: ~M-x customize-variable agda-input-user-translations~ then
~INS~ then for key sequence type ~set~ then ~INS~ and for string paste ~ùíÆ‚ÑØùìâ~.
#+begin_src emacs-lisp
(add-to-list 'agda-input-user-translations '("set" "ùíÆ‚ÑØùìâ"))
#+end_src
Better yet, as a loop:
#+begin_src emacs-lisp
(loop for item in
      '(
        ;; categorial
        ("alg" "ùíúùìÅ‚Ñä")
        ("split" "‚ñµ")
        ("join" "‚ñø")
        ("adj" "‚ä£")
        (";;" "Ôπî")
        (";;" "‚®æ")
        (";;" "‚àò")
        ;; lattices
        ("meet" "‚äì")
        ("join" "‚äî")
        ;; residuals
        ("syq"  "‚ï≥")
        ("over" "‚ï±")
        ("under" "‚ï≤")
        ;; Z-quantification range notation, e.g., ‚Äú‚àÄ x ‚ùô R ‚Ä¢ P‚Äù
        ("|" "‚ùô")
        ("with" "‚ùô")
        ;; adjunction isomorphism pair
        ("floor"  "‚åä‚åã")
        ("lower"  "‚åä‚åã")
        ("lad"    "‚åä‚åã")
        ("ceil"   "‚åà‚åâ")
        ("raise"  "‚åà‚åâ")
        ("rad"    "‚åà‚åâ")
        ;; more (key value) pairs here
        )
      do (add-to-list 'agda-input-user-translations item))
#+end_src
Also some silly stuff:
#+begin_src emacs-lisp
;; angry, cry, why-you-no
(add-to-list 'agda-input-user-translations
   '("whyme" "·Éö(‡≤†Áõä‡≤†)·Éö" "„ÉΩ‡ºº‡≤¢_‡≤¢‡ºΩÔæâ‚òÇ" "—â(„Çú„É≠„Çú—â)"))
;; confused, disapprove, dead, shrug
(add-to-list 'agda-input-user-translations
   '("what" "„Äå(¬∞„Éò¬∞)" "(‡≤†_‡≤†)" "(‚úñ‚ï≠‚ïÆ‚úñ)" "¬Ø\\_(„ÉÑ)_/¬Ø"))
;; dance, csi
(add-to-list 'agda-input-user-translations
   '("cool" "‚îè(-_-)‚îì‚îè(-_-)‚îõ‚îó(-_-Ôªø )‚îì" "‚Ä¢_‚Ä¢)
( ‚Ä¢_‚Ä¢)>‚åê‚ñ†-‚ñ†
(‚åê‚ñ†_‚ñ†)
"))
;; love, pleased, success, yesss
(add-to-list 'agda-input-user-translations
   '("smile" "‚ô•‚Äø‚ô•" "(‚îÄ‚Äø‚Äø‚îÄ)" "(‚Ä¢ÃÄ·¥ó‚Ä¢ÃÅ)Ÿà" "(‡∏á‡≤†_‡≤†)‡∏á"))
#+end_src

Finally let's effect such translations.
#+begin_src emacs-lisp
;; activate translations
(agda-input-setup)
#+end_src

#+results:

Note that the effect of [[http://ergoemacs.org/emacs/emacs_n_unicode.html][Emacs unicode input]] could be approximated using
~abbrev-mode~.

** Increase/decrease text size
The ‚Äòusual‚Äô text zoom keys ~C-¬±~ ‚Ä¶
#+begin_src emacs-lisp
(global-set-key (kbd "C-+") 'text-scale-increase)
(global-set-key (kbd "C--") 'text-scale-decrease)
;; C-x C-0 restores the default font size
#+end_src

If thou knowst the ELisp, forgive this shadowing of the ~negative-argument~
‚Ä¶ we've still got ~M--~ though.
** Moving Text Around
This extends Org-mode's ~M-‚Üë,‚Üì~ to other modes, such as when coding.
#+begin_src emacs-lisp
;; M-‚Üë,‚Üì moves line, or marked region; prefix is how many lines.
(use-package move-text)
(move-text-default-bindings)
#+end_src

** Enabling CamelCase Aware Editing Operations
[[https://www.gnu.org/software/emacs/manual/html_node/ccmode/Subword-Movement.html][Subword]] movement lets us treat ‚ÄúEmacsIsAwesome‚Äù as three words
‚îÄ‚ÄúEmacs‚Äù, ‚ÄúIs‚Äù, and ‚ÄúAwesome‚Äù‚îÄ which is desirable since such naming
is common among coders. Now, for example, ~M-f~ moves along each subword.

#+begin_src emacs-lisp
(global-subword-mode 1)
(diminish  'subword-mode)
#+end_src

** Mouse Editing Support
Text selected with the mouse is automatically copied to clipboard.
#+begin_src emacs-lisp
(setq mouse-drag-copy-region t)
#+end_src

** Delete Selection Mode
Delete Selection mode lets you treat an Emacs region much like a typical text
selection outside of Emacs: You can replace the active region.  We can delete
selected text just by hitting the backspace key.

#+begin_src emacs-lisp
(delete-selection-mode 1)
#+end_src
** ~M-n,p~: Word-at-Point Navigation
Let's mimic the ~C-n,p~ constructs from line to word, so that unoccupied ~M-n,p~ now
serve to take us to the next or previous instance of the word under the
cursor. This is less intrusive than searching ~C-s~ or listing all occurrences ~M-s
o~.
#+begin_src emacs-lisp
(use-package smartscan
  :config
    (global-set-key (kbd "M-n") 'smartscan-symbol-go-forward)
    (global-set-key (kbd "M-p") 'smartscan-symbol-go-backward)
    (global-set-key (kbd "M-'") 'my/symbol-replace))
#+end_src

Unfortunately, as it currently is, there is no universal argument support:
~C-u 2 M-p~ does /not/ take you to the second previous instance of a word
---the prefix is instead ignored.

The default symbol replacement is [[https://github.com/mickeynp/smart-scan/issues/23][over-zealous]] in that it replaces sub-terms
occurring as parts of larger words. Let's do something about that.
#+begin_src emacs-lisp
(defun my/symbol-replace (replacement)
  "Replace all standalone symbols in the buffer matching the one at point."
  (interactive  (list (read-from-minibuffer "Replacement for thing at point: " nil)))
  (save-excursion
    (let ((symbol (or (thing-at-point 'symbol) (error "No symbol at point!"))))
      (beginning-of-buffer)
      ;; (query-replace-regexp symbol replacement)
      (replace-regexp (format "\\b%s\\b" (regexp-quote symbol)) replacement))))
#+end_src
Also ‚Ä¶
#+begin_src emacs-lisp
;; C-n, next line, inserts newlines when at the end of the buffer
(setq next-line-add-newlines t)
#+end_src
** Letter-based Navigation
At a glance of possible positions, across windows,
and a key to jump there is a feature provided to us by [[https://github.com/winterTTr/ace-jump-mode/wiki/AceJump-FAQ][ace-jump]]
---here is an [[https://www.youtube.com/watch?feature=player_embedded&v=UZkpmegySnc#!][emacs-rocks 2-minute video]].

For example, =C-c SPC m= greys our all windows and places a red
letter at the start of any word that begins with /m/, then I may
press a letter to jump to the associated position in the
associated window. Using ~C-u C-c SPC~ and ~C-u C-u C-c SPC~ let
me jump to any character or to any visible line.

‚û© Super simple use case: Fix your eyes on an occurence of a word, then ~C-c SPC~
  to quickly jump to it so as to edit the sentence in which it occurs.
- It's like ~C-s~ but more lightweight.

#+begin_src emacs-lisp
(use-package ace-jump-mode
  :config (bind-key* "C-c SPC" 'ace-jump-mode))

;; See ace-jump issues to configure for use of home row keys.
#+end_src

There is a newer and somewhat more powerful package, [[https://github.com/abo-abo/avy][avy]], which accompishes the
same goal.  It uses a tree style to jumipng: Locations are given two letter
combinations, one presses one letter to jump to a group of text, then another
letter to jump somewhere in that grouping. I prefer ace-jump since it greys
everthing out, whereas avy surrounds jump locations with a box.
Here is an [[https://www.youtube.com/watch?v=zar4GsOBU0g][emacs-doom 6-minute video]] for avy.

There is also [[https://github.com/tam17aki/ace-isearch][ace-isearch]] for bridinging different navgiational methods ---one
begins incremental search, ~s-f~, then according to a pause and length of input,
one of the navgiational methods, such as isearch or avy or helm-swoop, will be
begun.  I'm okay with using ~C-s~ for helm-swoop and ~C-c SPC~ for ace-jump, and
still have ~s-f~ for incremental search, which I hardly use.

*What is bind-keys**?

Major modes provide specfic use and so their bindings always take precedence
over global bindings ---e.g., the major mode binding may do what the global does
but with extra mode-specfic behaviour, such as indentation. Other times, a major
mode's binding simply uses the same key presses with completely unrelated
behaviour.  If we want to avoid having our global keybindings shadowed by a
major mode, we may use the ~bind-key*~ /macro/ of ~use-package~, or the ~bind-keys*~
/macro/ when there are multiple keys; these are macros, not clauses.  ---These
essentially creates a dedicated minor mode behind the scenes, which saves us the
work of [[https://emacs.stackexchange.com/a/358/10352][doing it ourselves]].

|   | ~(bind-keys* (k‚ÇÅ . f‚ÇÅ) ‚Ä¶ (k‚Çô . f‚Çô))~                           |
| ‚âà | These keybindings override all minor modes that use keys =k·µ¢=. |

** ~C-c e n,p~: Taking a tour of one's edits
This package allows us to move around the edit points of a buffer
/without/ actually undoing anything. We even obtain a brief description
of what happend at each edit point.
This seems useful for when I get interrupted or lose my train of
thought: Just press ~C-c e p~ to see what I did recently and where
---the ‚Äúe‚Äù is for ‚Äúe‚Äùdit.

#+begin_src emacs-lisp
;; Give me a description of the change made at a particular stop.
(use-package goto-chg
  :init (setq glc-default-span 0))

(defhydra hydra-edits (global-map "C-c e")
  ("p" goto-last-change "Goto n·µó ∞ last change")
  ("n" goto-last-change-reverse "Goto more recent change"))
#+end_src

Compare this with ~C-x u~, or ~undo-tree-visualise~, wherein undos are actually performed.

Notice, as a hydra, I can use ~C-c e~ followed by any combination of
~p~ and ~n~ to navigate my recent edits /without/ having to supply the prefix
each time.

* Org-Mode Administrivia
Let's get Org-mode setup so that we can quickly move between headings and
org-blocks ---~n,p~ on heading starts and ~s-n,p~ on blocks---, then let's prettify
the leading stars of headings, Org's formatting delimiters, and even its blocks
delimiters by making them less intrusive thereby ‚Äòfading into the background‚Äô
and drawing minimal attention.  This has been useful when promoting Org-mode by
sharing my screen with others.
Let's obtain Org-mode along with the extras that allow us to ignore
heading names, but still utilise their contents ---e.g., such as a heading
named ‚Äòpreamble‚Äô that contains org-mode setup for a file.
#+begin_src emacs-lisp
(use-package org
  :ensure org-plus-contrib
  :config
  (require 'ox-extra)
  (ox-extras-activate '(ignore-headlines)))
#+end_src

~org-plus-contrib~ contain the files that are included with Emacs plus all
  contributions from the [[https://code.orgmode.org/bzg/org-mode/src/master/contrib][org-mode repoistory]].
- Use the ~:ignore:~ tag on headlines you'd like to have ignored, while not
  ignoring their content.
- Use the ~:noexport:~ tag to omit a headline /and/ its contents.

#+begin_src emacs-lisp
;; Replace the content marker, ‚Äú‚ãØ‚Äù, with a nice unicode arrow.
(setq org-ellipsis " ‚§µ")

;; Fold all source blocks on startup.
(setq org-hide-block-startup t)

;; Lists may be labelled with letters.
(setq org-list-allow-alphabetical t)

;; Avoid accidentally editing folded regions, say by adding text after an Org ‚Äú‚ãØ‚Äù.
(setq org-catch-invisible-edits 'show)

;; I use indentation-sensitive programming languages.
;; Tangling should preserve my indentation.
(setq org-src-preserve-indentation t)

;; Tab should do indent in code blocks
(setq org-src-tab-acts-natively t)

;; Give quote and verse blocks a nice look.
(setq org-fontify-quote-and-verse-blocks t)

;; Pressing ENTER on a link should follow it.
(setq org-return-follows-link t)
#+end_src

I rarely use tables, but here is a useful [[http://notesyoujustmightwanttosave.blogspot.com/][Org-Mode Table Editing Cheatsheet]] and
a [[http://www.howardism.org/Technical/Emacs/spreadsheet.html][friendly tutorial]].

Moreover, since I end up using org-mode most of the time, let's make that the
default mode.
#+begin_src emacs-lisp
(setq initial-major-mode 'org-mode)
#+end_src

** Executing code from ~src~ blocks
For example, to execute a shell command in Emacs, write a ~src~ with a shell
command, then ~C-c c-c~ to see the results.  Emacs will generally query you to
ensure you're confident about executing the (possibly dangerous) code block;
let's stop that:
#+begin_src emacs-lisp
;; Seamless use of babel: No confirmation upon execution.
;; Downside: Could accidentally evaluate harmful code.
(setq org-confirm-babel-evaluate nil)
#+end_src

A worked out example can be obtained as follows: ~<g TAB~ then ~C-c C-C~ to make a nice
simple graph ---the code for this is in the next section.

Some initial languages we want org-babel to support:
#+begin_src emacs-lisp
 (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (shell      . t)
     (python     . t)
     (haskell    . t)
     (ruby       . t)
     (ocaml      . t)
     (C          . t)  ;; Captial ‚ÄúC‚Äù gives access to C, C++, D
     (dot        . t)
     (latex      . t)
     (org        . t)
     (makefile   . t)))

;; Preserve my indentation for source code during export.
(setq org-src-preserve-indentation t)

;; The export process hangs Emacs, let's avoid this.
;; MA: For one reason or another, this crashes more than I'd like.
;; (setq org-export-in-background t)
#+end_src

More languages can be added using ~add-to-list~.

** High Speed Literate Programming

*** Manipulating Sections
Let's enable the [[http://notesyoujustmightwanttosave.blogspot.com/2011/12/org-speed-keys.html][Org Speed Keys]] so that when the cursor is at the beginning of
a headline, we can perform fast manipulation & navigation using the standard Emacs movement
controls, such as:
- ~#~ toggle ~COMMENT~-ing for an org-header.
- ~s~ toggles ‚Äúnarrowing‚Äù to a subtree; i.e., hide the rest of the document.

  If you narrow to a subtree then any export, ~C-c C-e~, will only consider
  the narrowed detail.

- ~I/O~ clock In/Out to the task defined by the current heading.
  - Keep track of your work times!
  - ~v~ view agenda.
- ~u~ for jumping upwards to the parent heading.
- ~c~ for cycling structure below current heading, or ~C~ for cycling global structure.
- ~i~ insert a new same-level heading below current heading.
- ~w~ refile current heading; options list pops-up to select which heading to move it to. Neato!
- ~t~ cycle through the available TODO states.
- ~^~ sort children of current subtree; brings up a list of sorting options.
- ~n/p~ for next/previous /visible/ heading.
- ~f/b~ for jumping forward/backward to the next/previous /same-level/ heading.
- ~D/U~ move a heading down/up.
- ~L/R~ recursively promote (move leftwards) or demote (more rightwards) a heading.
- ~1,2,3~ to mark a heading with priority, highest to lowest.

We can add our own speed keys by altering the ~org-speed-commands-user~
association list variable.

Moreover, ~?~ to see a complete list of keys available.
#+begin_src emacs-lisp
(setq org-use-speed-commands t)
#+end_src

*** Seamless Navigation Between Source Blocks
The ‚Äúsuper key‚Äù ---aka the command or windows key--- can be used to jump to the
previous, next, or toggle editing org-mode source blocks.
#+begin_src emacs-lisp
;; Overriding keys for printing buffer, duplicating gui frame, and isearch-yank-kill.
;;
(use-package org
  :bind (:map org-mode-map
              ("s-p" . org-babel-previous-src-block)
              ("s-n" . org-babel-next-src-block)
              ("s-e" . org-edit-src-code)
         :map org-src-mode-map
              ("s-e" . org-edit-src-exit)))
#+end_src

Interestingly, ~s-l~ is ‚Äúgoto line‚Äù.

*** Modifying ~<return>~
- ~C-RET, C-S-RET~ make a new heading where the latter marks it as a ~TODO~.
- By default ~M-RET~ makes it easy to work with existing list items, headings,
  tables, etc by creating a new item, heading, etc.

Usually we want a newline then we indent, let's make that the default.
#+begin_src emacs-lisp
(add-hook 'org-mode-hook '(lambda ()
   (local-set-key (kbd "<return>") 'org-return-indent))
   (local-set-key (kbd "C-M-<return>") 'electric-indent-just-newline))
#+end_src

Notice that I've also added another kind of return, for when I want to
break-out of the indentation approach and start working at the beginning of
the line.

In summary:
| key            | method                                    | behaviour                           |
|----------------+-------------------------------------------+-------------------------------------|
| ~<return>~     | ~org-return-indent~                       | Newline with indentation            |
| ~M-<return>~   | ~org-meta-return~                         | Newline with new org item           |
| ~C-M-<return>~ | ~electric-indent-just-newline~            | Newline, cursor at start            |
| ~C-<return>~   | ~org-insert-heading-respect-content~      | New heading /after/ current content |
| ~C-S-<return>~ | ~org-insert-todo-heading-respect-content~ | Ditto, but with a ~TODO~ marker     |

*** ~C-a,e,k~ and Yanking of sections
On an org-heading, =C-a= goes to after the star, heading markers.
To use speed keys, run =C-a C-a= to get to the star markers.

=C-e= goes to the end of the heading, not including the tags.
#+begin_src emacs-lisp
(setq org-special-ctrl-a/e t)
#+end_src

=C-k= no longer removes tags, if activated in the middle of a heading's name.
#+begin_src emacs-lisp
(setq org-special-ctrl-k t) ;; MA: Does not work ‚Ä¶!
#+end_src

When you yank a subtree and paste it alongside a subtree of depth /‚Äòd‚Äô/, then the
yanked tree's depth is adjusted to become depth /‚Äòd‚Äô/ as well.  If you don't want
this, then refile instead of copy-pasting.
#+begin_src emacs-lisp
(setq org-yank-adjusted-subtrees t)
#+end_src

** Hiding Emphasise Markers & Inlining Images
#+begin_src emacs-lisp
;; org-mode math is now highlighted ;-)
(setq org-highlight-latex-and-related '(latex))

;; Hide the *,=,/ markers
(setq org-hide-emphasis-markers t)

;; (setq org-pretty-entities t)
;; to have \alpha, \to and others display as utf8
;; http://orgmode.org/manual/Special-symbols.html
#+end_src

The following is now disabled ---it makes my system slower than I'd like.
#+begin_src emacs-lisp :tangle no
;; Let's set inline images.
(setq org-display-inline-images t)
(setq org-redisplay-inline-images t)
(setq org-startup-with-inline-images "inlineimages")

;; Automatically convert LaTeX fragments to inline images.
(setq org-startup-with-latex-preview t)
#+end_src

** Org-Emphasise for Parts of Words                                :Disabled:
From [[https://stackoverflow.com/a/24540651/3550444][stackoverflow]], the following incantation allows us to have
parts of works emphasied with org-mode; e.g.,
/half/ed, ~half~ed, and right in the m*idd*le! Super cool stuff!
#+begin_src emacs-lisp :tangle no
(setcar org-emphasis-regexp-components " \t('\"{[:alpha:]")
(setcar (nthcdr 1 org-emphasis-regexp-components) "[:alpha:]- \t.,:!?;'\")}\\")
(org-set-emph-re 'org-emphasis-regexp-components org-emphasis-regexp-components)
#+end_src

I've disabled this feature since multiple occurrences
of an emphasise marker are sometimes treated as one
lengthy phrase being emphasised.

** Show off-screen heading at the top of the window
In case we forgot which heading we're under, let's keep
the current heading stuck at the top of the window.
#+begin_src emacs-lisp
 (use-package org-sticky-header
  :hook (org-mode . org-sticky-header-mode)
  :config
  (setq-default
   org-sticky-header-full-path 'full
   ;; Child and parent headings are seperated by a /.
   org-sticky-header-outline-path-separator " / "))
#+end_src

** Jumping without hassle
#+begin_src emacs-lisp
(defun my/org-goto-line (line)
  "Go to the indicated line, unfolding the parent Org header.

   Implementation: Go to the line, then look at the 1st previous
   org header, now we can unfold it whence we do so, then we go
   back to the line we want to be at.
  "
  (interactive "nEnter line: ")
  (goto-line line)
  (org-previous-visible-heading 1)
  (org-cycle)
  (goto-line line))
#+end_src

** Folding within a subtree
#+begin_src emacs-lisp
(defun my/org-fold-current-subtree-anywhere-in-it ()
  "Hide the current heading, while being anywhere inside it."
  (interactive)
  (save-excursion
    (org-narrow-to-subtree)
    (org-shifttab)
    (widen)))

(add-hook 'org-mode-hook '(lambda ()
  (local-set-key (kbd "C-c C-h") 'my/org-fold-current-subtree-anywhere-in-it)))
#+end_src

** Making Block Delimiters Less Intrusive
Let us render Org-mode's ~#+begin_src~ and ~#+end_src~ less obtrusively by, e.g.,
having the former render as a pencil marker ‚úé and the latter as a tombstone ‚ñ°
---reminiscent of Halmos' QED end-of-proof marker.  His setup also accounts for
quotes.

‚ü™ Incantation Omitted ---Visit [[https://pank.eu/blog/pretty-babel-src-blocks.html#coderef-symbol][Rasmus Roulund]]'s site & copy-paste it, if you wish ‚ü´
#+begin_src emacs-lisp
(add-hook 'org-mode-hook #'rasmus/org-prettify-symbols)
(org-mode-restart)
#+end_src

His development relies on built-in prettify-symbols-mode, which
disguises strings in a buffer for the sake of readability or
aesthetics.  Following the example in the documentation, ~C-h f
prettify-symbols-mode~, we can quickly approximate his efforts for
~example~ blocks as follows, however a main issue is that source blocks
have busybodied headers which his setup disguises as ‚Äò‚â°‚Äô.
#+begin_src emacs-lisp :tangle yes
(global-prettify-symbols-mode)

(defvar my/prettify-alist nil
  "Musa's personal prettifications.")

(loop for pair in '(("<=" . ?‚â§) (">=" . ?‚â•)
                    ("->" . ?‚Üí) ("-->". ?‚ü∂) ;; threading operators
                    ("#+begin_example" . (?‚Ñ∞ (Br . Bl) ?‚áí)) ;; ‚Ñ∞‚áí
                    ("#+end_example"   . ?‚áê))                ;; ‚áê

      do (push pair my/prettify-alist))

(loop for hk in '(text-mode-hook prog-mode-hook org-mode-hook)
      do (add-hook hk (lambda ()
                        (setq prettify-symbols-alist
                              (append my/prettify-alist prettify-symbols-alist)))))
#+end_src

See [[http://www.modernemacs.com/post/prettify-mode/][‚ÄúMathematical Notation in Emacs‚Äù]] for how such prettifications can
make verbose (Python) scripts much more readable by employing more
economical disguises.

A nice sanity:
#+begin_src emacs-lisp
;; Un-disguise a symbol when cursour is inside it or at the right-edge of it.
(setq prettify-symbols-unprettify-at-point 'right-edge)
#+end_src

* Org-Mode ‚áí PDF & HTML
In this section we consider the Org-mode exporters for PDFs and
HTMLs. For example, we account for LaTeX citations and reliable HTML
anchors.

** Working with Citations
[[https://github.com/jkitchin/org-ref][An exquisite system]] for handling references.

The following entity will display useful data
when the mouse hovers over it (‚Ä¢ÃÄ·¥ó‚Ä¢ÃÅ)Ÿà If you click on it, then you're
in for a lot of super neat stuff, such as searching for the pdf online!

[[#agda_overview][agda_overview]]

#+begin_src emacs-lisp
;; Files to look at when no ‚Äú‚ï≤bibliography{‚ãØ}‚Äù is not present in a file.
;; Most useful for non-LaTeX files.
(setq reftex-default-bibliography '("~/thesis-proposal/papers/References.bib"))
(setq bibtex-completion-bibliography (car reftex-default-bibliography))

(use-package org-ref
  :config (setq org-ref-default-bibliography reftex-default-bibliography))

(use-package helm-bibtex)
#+end_src

Execute ~M-x helm-bibtex~ or ~C-c ] and, say, enter ~agda~ and you will be presented with
all the entries in the bib database that mention ‚Äòagda‚Äô. Super cool stuff.

Read the manual [[https://github.com/jkitchin/org-ref/blob/master/org-ref.org][online]] or better yet as an org-file with ~M-x
  org-ref-help~.

This is an Org-mode application since the citations have tooltips
and export nicely to LaTeX & HTML via the Org-mode exporter.

** Coloured LaTeX using Minted
Execute the following for bib ref as well as minted Org-mode uses the
Minted package for source code highlighting in PDF/LaTeX ---which in
turn requires the pygmentize system tool.
#+begin_src emacs-lisp
(setq org-latex-listings 'minted
      org-latex-packages-alist '(("" "minted"))
      org-latex-pdf-process
      '("pdflatex -shell-escape -output-directory %o %f"
        "biber %b"
        "pdflatex -shell-escape -output-directory %o %f"
        "pdflatex -shell-escape -output-directory %o %f"))
#+end_src

For faster pdf generation, possibly with errors, consider invoking:
#+begin_example emacs-lisp
(setq org-latex-pdf-process
      '("pdflatex -interaction nonstopmode -output-directory %o %f"))
#+end_example

By default, Org exports LaTeX using the ~nonstopmode~ option, which tries
its best to produce a PDF ---which ignores typesetting errors altogether,
which is not necessary ideal when using LaTeX.

** Ensuring Useful HTML Anchors
Upon HTML export, each tree heading is assigned an ID to be used for hyperlinks.
Default IDs are something like ~org1957a9d~, which does not endure the test of time:
Re-export will produce a different id. Here's a rough snippet to generate
IDs from headings, by replacing spaces with hyphens, for headings without IDs.

#+begin_src emacs-lisp :tangle yes
(defun my/ensure-headline-ids (&rest _)
  "Org trees without a

All non-alphanumeric characters are cleverly replaced with ‚Äò-‚Äô.

If multiple trees end-up with the same id property, issue a
message and undo any property insertion thus far.

E.g., ‚ÜØ We'll go on a ‚àÄ‚àÉ‚áÖ adventure
   ‚Ü¶  We'll-go-on-a-adventure
"
  (interactive)
  (let ((ids))
    (org-map-entries
     (lambda ()
       (org-with-point-at (point)
         (let ((id (org-entry-get nil "CUSTOM_ID")))
           (unless id
             (thread-last (nth 4 (org-heading-components))
               (s-replace-regexp "[^[:alnum:]']" "-")
               (s-replace-regexp "-+" "-")
               (s-chop-prefix "-")
               (s-chop-suffix "-")
               (setq id))
             (if (not (member id ids))
                 (push id ids)
               (message-box "Oh no, a repeated id!\n\n\t%s" id)
               (undo)
               (setq quit-flag t))
             (org-entry-put nil "CUSTOM_ID" id))))))))

;; Whenever html & md export happens, ensure we have headline ids.
(advice-add 'org-html-export-to-html   :before 'my/ensure-headline-ids)
(advice-add 'org-md-export-to-markdown :before 'my/ensure-headline-ids)
#+end_src

One may then use ~[[#my-custom-id]]~ to link to the entry with ~CUSTOM_ID~
property ~my-custom-id~.

Interestingly, ~org-set-property~, ~C-c C-x p~, lets us insert a property
from a selection of available ones, then we'll be prompted for a value
for it from a list of values you've used elsewhere. This is useful for
remaining consistent for when trees share similar properties.

** HTML ‚ÄúFolded Drawers‚Äù
#+begin_src emacs-lisp
(defun my/org-drawer-format (name contents)
  "Export to HTML the drawers named with prefix ‚Äòfold_‚Äô, ignoring case.

The resulting drawer is a ‚Äòcode-details‚Äô and so appears folded;
the user clicks it to see the information therein.
Henceforth, these are called ‚Äòfold drawers‚Äô.

Drawers without such a prefix may be nonetheless exported if their
body contains ‚Äò:export: t‚Äô ---this switch does not appear in the output.
Thus, we are biased to generally not exporting non-fold drawers.

One may suspend export of fold drawers by having ‚Äò:export: nil‚Äô
in their body definition.

Fold drawers naturally come with a title.
Either it is specfied in the drawer body by ‚Äò:title: ‚ãØ‚Äô,
or otherwise the drawer's name is used with all underscores replaced
by spaces.
"
  (let* ((contents‚Ä≤ (replace-regexp-in-string ":export:.*\n?" "" contents))
         (fold? (s-prefix? "fold_" name 'ignore-case))
         (export? (string-match ":export:\s+t" contents))
         (not-export? (string-match ":export:\s+nil" contents))
         (title‚Ä≤ (and (string-match ":title:\\(.*\\)\n" contents)
                      (match-string 1 contents))))

    ;; Ensure we have a title.
    (unless title‚Ä≤ (setq title‚Ä≤ (s-join " " (cdr (s-split "_" name)))))

    ;; Output
    (cond
     ((and export? (not fold?)) contents‚Ä≤)
     (not-export? nil)
     (fold?
      (thread-last contents‚Ä≤
        (replace-regexp-in-string ":title:.*\n" "")
        (format "<details class=\"code-details\"> <summary> <strong>
            <font face=\"Courier\" size=\"3\" color=\"green\"> %s
            </font> </strong> </summary> %s </details>" title‚Ä≤))))))

(setq org-html-format-drawer-function 'my/org-drawer-format)
#+end_src

With the following invocations we only see the odd indexed ‚Äòhello‚Äôs, where the
latter two are folded up.
#+begin_src org :tangle no
:this-drawer-is-exported:
:export: t
hello 1
:End:

:this-drawer-is-NOT-exported:
hello 2
:End:

:fold_This_drawer_has_a_title_in_the_body:
:title: I am the drawer title 0

hello 3
:End:

:fold_This_drawer_is_NOT_exported:
:title: Why are we here?
:export: nil

hello 4
:End:

:fold_I_am_the_drawer_title_1:

hello 5
:End:
#+end_src

I doubt I could show an example in the Github README, since no HTML export is
happening using my setup. In case you're reading this on my blog, which has
exported HTML. Here's the example:
Now that I've written this, I'm thinking it may have been preferably to use an org-block‚Ä¶?

** [[https://revealjs.com/?transition=zoom#/][Reveal.JS]] -- The HTML Presentation Framework
Org-mode documents can be transformed into beautiful slide decks
with [[https://github.com/yjwen/org-reveal/blob/master/Readme.org][org-reveal]] with the following two simple lines.

#+begin_src emacs-lisp
(use-package ox-reveal
  :config (setq org-reveal-root "https://cdn.jsdelivr.net/npm/reveal.js"))
#+end_src

For example, execute, ~C-x C-e~ after the closing parenthesis of, the
following block to see an example slide-deck (‚îÄ‚Äø‚Äø‚îÄ)
#+begin_src emacs-lisp :tangle no
(progn (shell-command "curl https://raw.githubusercontent.com/yjwen/org-reveal/696613edef0fe17a9c53146f79933fe7c4101100/Readme.org >> Trying_out_reveal.org")
       (switch-to-buffer (find-file "Trying_out_reveal.org"))
       (org-reveal-export-to-html-and-browse))
#+end_src

Org-mode exporting, ~C-c C-e~, now includes an option ~R~ for such reveal slide decks.

Two dimensional slides may be a bit new to some people, so I like to
give viewers an option, in tiny font, to view the slide-deck
continuously and remind them that ~?~ provides useful shortcuts.
#+begin_src emacs-lisp
(setq org-reveal-title-slide "<h1>%t</h1> <h3>%a</h3>
<font size=\"1\">
<a href=\"?print-pdf&showNotes=true\">
‚ü™ Flattened View ; Press <code>?</code> for Help ‚ü´
</a>
</font>")
#+end_src
One should remove the ~&showNotes=true~ if they do not want to include
speaker notes in the flattened view.

Within the flatenned view, one may wish to ~CTRL/CMD+P~ then save the
resulting PDF locally.

* Life within Org-mode
It's hard to estimate how long a task takes if you don't keep
‚Äòclock-in and clock-out‚Äô of tasks. We can ‚Äòcapture‚Äô todos right in the middle
of a task /without/ context-switching; e.g., no opening a todos file!
After some reflection on the relative importance of the tasks, we can
schedule them into our ‚Äòagenda‚Äô.

Let's do this!

** Using Org-Mode as a Day Planner
‚ü™ This section is based on a dated, yet delightful, tutorial
            of the same title by [[http://newartisans.com/2007/08/using-org-mode-as-a-day-planner/][John Wiegley]]. ‚ü´

We want a day-planner with the following use:
1. ‚ÄúMindlessly‚Äù & rapidly create new tasks.
2. Schedule and archive tasks at the end, or start, of the work day.
3. Glance at a week's tasks, shuffle if need be.
4. Prioritise the day's tasks. Aim for ‚â§15 tasks.
5. Progress towards completion of ~A~ tasks by documenting work completed.
6. Repeat! During the day, if anything comes up, capture it and intentionally
   forget about it.

*** Capturing ideas & notes without interrupting the current workflow
[[https://orgmode.org/org.html#Setting-up-capture][Capture]] lets me quickly make notes & capture ideas, with associated reference material,
without any interruption to the current work flow. Without losing focus on what you're doing,
quickly jot down a note of something important that just came up.

E.g., I have a task, or something I wish to note down, rather than opening
some file, then making a heading, then writing it; instead, I press
~C-c c t~ and a pop-up appears, I make my note, and it disappears ---with my
notes file(s) now being altered! Moreover, by default it provides a timestamp
and a link to the file location where I made the note ---helpful for tasks, tickets,
to be tackled later on.

#+begin_src emacs-lisp
;; Location of my todos/notes file
(setq org-default-notes-file "~/Dropbox/todo.org")

;; ‚ÄúC-c c‚Äù to quickly capture a task/note
(define-key global-map "\C-cc" 'org-capture)
#+end_src

By default we only get a ‚Äòtasks‚Äô form of capture, let's add some more.
#+begin_src emacs-lisp
(cl-defun my/make/org-capture-template
   (shortcut heading &optional (no-todo nil) (description heading) (category heading) (scheduled t))
  "Quickly produce an org-capture-template.

  After adding the result of this function to ‚Äòorg-capture-templates‚Äô,
  we will be able perform a capture with ‚ÄúC-c c ‚Äòshortcut‚Äô‚Äù
  which will have description ‚Äòdescription‚Äô.
  It will be added to the tasks file under heading ‚Äòheading‚Äô
  and be marked with category  ‚Äòcategory‚Äô.

  ‚Äòno-todo‚Äô omits the ‚ÄòTODO‚Äô tag from the resulting item; e.g.,
  when it's merely an interesting note that needn't be acted upon.
  ‚îÄProbably a bad idea‚îÄ

  Defaults for ‚Äòdescription‚Äô and ‚Äòcategory‚Äô are set to the same as
  the ‚Äòheading‚Äô. Default for ‚Äòno-todo‚Äô is ‚Äònil‚Äô.

  Scheduled items appear in the agenda; true by default.

  The target is ‚Äòfile+headline‚Äô and the type is ‚Äòentry‚Äô; to see
  other possibilities invoke: C-h o RET org-capture-templates.
  The ‚Äú%?‚Äù indicates the location of the Cursor, in the template,
  when forming the entry.
  "
  `(,shortcut ,description entry
      (file+headline org-default-notes-file
         ,(concat heading "\n#+CATEGORY: " category))
         , (concat "*" (unless no-todo " TODO") " %?\n"
                (when nil ;; this turned out to be a teribble idea.
                  ":PROPERTIES:\n:"
                (if scheduled
                    "SCHEDULED: %^{Any time ‚âà no time! Please schedule this task!}t"
                  "CREATED: %U")
                "\n:END:") "\n\n ")
      :empty-lines 1 :time-prompt t))

(setq org-capture-templates
      (loop for (shortcut heading)
            in (-partition 2 '("t" "Tasks, Getting Things Done"
                               "r" "Research"
                               "m" "Email"
                               "e" "Emacs (‚Ä¢ÃÄ·¥ó‚Ä¢ÃÅ)Ÿà"
                               "b" "Blog"
                               "a" "Arbitrary Reading and Learning"
                               "p" "Personal Matters"))
            collect  (my/make/org-capture-template shortcut heading)))

;; For now, let's automatically schedule items a week in advance.
;; TODO: FIXME: This overwrites any scheduling I may have performed.
(defun my/org-capture-schedule ()
  (org-schedule nil "+7d"))

(add-hook 'org-capture-before-finalize-hook 'my/org-capture-schedule)
#+end_src

For now I capture everything into a single file.  One would ideally keep
separate client, project, information in its own org file.  The ~#+CATEGORY~
appears alongside each task in the agenda view ---keep reading.

- Looking at ~my/make/org-capture-template~, one notices that capture actually
  lets you add /any/ type of item to /any/ file.

Let's also ensure TODO-s respect hierarchical structure.
#+begin_src emacs-lisp
;; Cannot mark an item DONE if it has a  TODO child.
;; Conversely, all children must be DONE in-order for a parent to be DONE.
(setq org-enforce-todo-dependencies t)
#+end_src

*Where am I currently capturing?*
- During meetings, when a nifty idea pops into my mind, I quickly capture it.
  - I've found taking my laptop to meetings makes me an active listener
    and I get much more out of my meetings since I'm taking notes.
- Through out the day, as I browse the web, read, and work; random ideas pop-up, and I capture them indiscriminately.
- I envision that for a phone call, I would open up a capture to make note of what the call entailed so I can review it later.
- Anywhere you simply want to make a note, for the current heading, just press
  ~C-c C-z~. The notes are just your remarks along with a timestamp; they are
  collected at the top of the tree, under the heading.

  #+begin_src emacs-lisp
    ;; Ensure notes are stored at the top of a tree.
    (setq org-reverse-note-order nil)
  #+end_src

- Org-protocol is a way to create capture notes in org-mode from other applications.

Anyhow‚Ä¶
*** Step 1: When new tasks come up
Isn't it great that we can squirrel away info into some default location
then immediately return to what we were doing before ---with speed & minimal distraction! ‚ô•‚Äø‚ô•
Indeed, if our system for task management were slow then we may not produce
tasks and so forget them altogether! —â(„Çú„É≠„Çú—â)

- Entering tasks is a desirably impulsive act; do not make any further
  scheduling considerations.

  The next step, the review stage occurring at the end or the start of the
  workday, is for processing.

#+begin_quote
The reason for this is that entering new tasks should be impulsive, not reasoned.
Your reasoning skills are required for the task at hand, not every new tidbit.
You may even find that during the few hours that transpire between creating a
task and categorizing it, you‚Äôve either already done it or discovered it doesn‚Äôt
need to be done at all! ---[[http://newartisans.com/2007/08/using-org-mode-as-a-day-planner/][John Wiegley]]
#+end_quote

When my computer isn't handy, I'll make a note on my phone then transfer it later.
*** Step 2: Filing your tasks
At a later time, a time of reflection, we go to our tasks list and actually
schedule time to get them done by ~C-c C-s~ then pick a date by entering a number
in the form ~+ùìÉ~ to mean that task is due ~ùìÉ~ days from now.

- Tasks with no due date are ones that ‚Äúcould happen anytime‚Äù, most likely no time at all.
- At least schedule tasks reasonably far off in the future, then reassess when the time comes.
- An uncompleted task is by default rescheduled to the current day, each day, along with how overdue it is.
  - Aim to consciously reschedule such tasks!

  With time, it will become clear what is an unreasonable day
  verses what is an achievable day.

Let's keep track of how many times, and when, we have pushed events to other dates.
#+begin_src emacs-lisp
;; Add a note whenever a task's deadline or scheduled date is changed.
(setq org-log-redeadline 'time)
(setq org-log-reschedule 'time)
#+end_src
*** Step 3: Quickly review the upcoming week
The next day we begin our work, we press ~C-c a a~ to see the
scheduled tasks for this week ---~C-c C-s~ to re-schedule the
task under the cursor and ~r~ to refresh the agenda.
#+begin_src emacs-lisp
(define-key global-map "\C-ca" 'org-agenda)
#+end_src

*** Step 4: Getting ready for the day
After having seen our tasks for the week, we press ~d~ to enter daily view
for the current day. Now we decide whether the items for today are
~A~: of high urgency & important; ~B~: of moderate urgency & importance; or
~C~: Pretty much optional, or very quick or fun to do.
- ~A~ tasks should be both important /and/ urgently done on the day they were scheduled.
  - Such tasks should be relatively rare!
  - If you have too many, you're anxious about priorities and rendering
    priorities useless.
- ~C~ tasks can always be scheduled for another day without much worry.
  - Act! If the thought of rescheduling causes you to worry, upgrade it to a
    ~B~ or ~A~.
- As such, most tasks will generally be priority ~B~:
  Tasks that need to be done, but the exact day isn't as critical as with an
  ~A~ task. These are the ‚Äúbread and butter‚Äù tasks that make up your day to day
  life.

On a task item, or any org-heading, press ~,~ then one of ~A, B, C~ to set its
priority.  Then ~r~ to refresh.

*** Step 5: Doing the work
Since ~A~ tasks are the important and urgent ones, if you do all of the ~A~ tasks and
nothing else today, no one would suffer. It's a good day (‚îÄ‚Äø‚Äø‚îÄ).

There should be no scheduling nor prioritising at this stage.
You should not be touching your tasks file until your next review session:
Either at the end of the day or the start of the next.

- Leverage priorities! E.g., When a full day has several ~C~ tasks, reschedule
  them for later in the week without a second thought.
  - You've already provided consideration when assigning priorities.

*** Step 6: Moving a task toward completion
My workflow states are described in the section
[[Workflow States]] and contain states: ~TODO, STARTED, WAITING, ON_HOLD, CANCELLED, DONE~.
- Tasks marked ~WAITING~ are ones for which we are awaiting some event, like someone
  to reply to our query. As such, these tasks can be rescheduled until I give up
  or the awaited event happens ---in which case I go to ~STARTED~ and document
  the reply to my query.
- The task may be put off indefinitely with ~ON_HOLD~, or I may choose never to do it
  with ~CANCELLED~. Along with ~DONE~, these three mark a task as completed
  and so it needn't appear in any agenda view.

I personally clock-in and clock-out of tasks ---keep reading---, where upon
clocking-out I'm prompted for a note about what I've accomplished so far.
Entering a comment about what I've done, even if it's very little, feels like
I'm getting something done. It's an explicit marker of progress.

In the past, I would make a ‚Äúcaptain's log‚Äù at the end of the day, but that's
like commenting code after it's written, I didn't always feel like doing it and
it wasn't that important after the fact. The continuous approach of noting after
every clock-out is much more practical, for me at least.

*** Step 7: Archiving Tasks
During the review state, when a task is completed, ‚Äòarchive‚Äô it with ~C-c C-x
C-s~: This marks it as done, adds a time stamp, and moves it to a local
~*.org_archive~ file. What was our ‚Äòto do‚Äô list becomes a ‚Äòta da‚Äô list showcasing
all we have done (‚Ä¢ÃÄ·¥ó‚Ä¢ÃÅ)Ÿà

Archiving keeps task lists clutter free, but unlike deletion it allows us,
possibly rarely, to look up details of a task or what tasks were completed in a
certain time frame ---which may be a motivational act, to see that you have
actually completed more than you thought, provided you make and archive tasks
regularly. We can use ~M-x org-search-view~ to search an org file /and/ the archive
file too, if we enable it so.
#+begin_src emacs-lisp
;; C-c a s ‚û© Search feature also looks into archived files.
;; Helpful when need to dig stuff up from the past.
(setq org-agenda-text-search-extra-files '(agenda-archives))
#+end_src

#+begin_src emacs-lisp
;; Invoking the agenda command shows the agenda and enables
;; the org-agenda variables.
(org-agenda "a" "a") ;; ‚û© Show my agenda upon Emacs startup.
#+end_src

Let's install some helpful views for our agenda.

- ~C-c a c~: See completed tasks at the end of the day and archive them.
  #+begin_src emacs-lisp
  ;; Pressing ‚Äòc‚Äô in the org-agenda view shows all completed tasks,
  ;; which should be archived.
  (add-to-list 'org-agenda-custom-commands
    '("c" todo "DONE|ON_HOLD|CANCELLED" nil))
  #+end_src

- ~C-c a u~: See unscheduled, undeadlined, and undated tasks in my todo files.
  Which should then be scheduled or archived.
  #+begin_src emacs-lisp
  (add-to-list 'org-agenda-custom-commands
    '("u" alltodo ""
       ((org-agenda-skip-function
          (lambda ()
                (org-agenda-skip-entry-if 'scheduled 'deadline 'regexp  "\n]+>")))
                (org-agenda-overriding-header "Unscheduled TODO entries: "))))
  #+end_src

** Super Agenda
The following incentivizes us to make use of ~:tags:~ so that our agenda displays
the tasks of the day depending on their tags ---possibly using complex predicates.
/This is far preferable to having them all in one big list./
#+begin_src emacs-lisp
(use-package org-super-agenda
  :config
  (org-super-agenda-mode)
  (setq org-super-agenda-groups
        ;; Default order is 0, first come first serve.
        ;; Items are ‚Äúor‚Äù-ed by default.
        '((:name "Important"
                 :tag "PackageFormer"
                 :and (:tag "JC" :priority "A")
                 :and (:tag "WK" :priority "A")
                 :priority "A")

          ;; Groups supply their own section names when none are given
          (:tag "personal")
          (:tag "3mi3")
          (:name "Emacs Init" :tag "init")
          (:priority<= "B" :order 1))))
#+end_src

The [[https://github.com/alphapapa/org-super-agenda][org-super-agenda]] homepage shows complex configurations and pleasant screenshots
contrasting with and without the system.

** Automating [[https://en.wikipedia.org/wiki/Pomodoro_Technique][Pomodoro]] ---‚ÄúCommit for only 25 minutes!‚Äù
Effort estimates are for an entire task.
Yet, sometimes it's hard to even get started on some tasks.

- The code below ensures a 25 minute timer is started whenever clocking in happens.

  - The timer is in the lower right of the modeline.

- When the timer runs out, we get a notification.

- We may have the momentum to continue on the difficult task, or clock-out and
  take a break after documenting what was accomplished.

#+begin_src emacs-lisp
;; Tasks get a 25 minute count down timer
(setq org-timer-default-timer 25)

;; Use the timer we set when clocking in happens.
(add-hook 'org-clock-in-hook
  (lambda () (org-timer-set-timer '(16))))

;; unless we clocked-out with less than a minute left,
;; show disappointment message.
(add-hook 'org-clock-out-hook
  (lambda ()
  (unless (s-prefix? "0:00" (org-timer-value-string))
     (message-box "The basic 25 minutes on this difficult task are not up; it's a shame to see you leave."))
     (org-timer-stop)))
#+end_src

Note that this does not conflict with the total effort estimate for the task.

‚ü® I'm told there's a package already made for this ---maybe I need to stop writing
good, and do more searches; then again, I've learned a lot by writing code. ‚ü©

** Journaling
Thus far I've made it easy to quickly capture ideas and tasks, not so much on
the analysis phase:

- What was accomplished today?
- What are some notably bad habits? Good habits?
- What are some future steps?

Rather than overloading the capture mechanism for such thoughts, let's employ
~org-journal~ ---journal entries are stored in files such as ~journal/20190407~,
where the file name is simply the date, or only one file per year as I've set it
up below.  Each entry is the week day, along with the date, then each child tree
is an actual entry with a personal title preceded by the time the entry was
made.  Unlike capture and its agenda support, journal ensures entries are
maintained in chronological order with calendar support.

Since org files are plain text files, an entry can be written anywhere and later
ported to the journal.

The separation of concerns is to emphasise the capture stage as being quick and
relatively mindless, whereas the journaling stage as being mindful.  Even though
we may utilise capture to provide quick support for including journal entries, I
have set my journal to be on a yearly basis ---one file per year--- since I want
to be able to look at previous entries when making the current entry; after all,
it's hard to compare and contrast easily unless there's multiple entries opened
already.

As such, ideally at the end of the day, I can review what has happened, and what
has not, and why this is the case, and what I intend to do about it, and what
problems were encountered and how they were solved ---in case the problem is
encountered again in the future.  *Consequently, if I encounter previously
confronted situations, problems,* *all I have to do is reread my journal to get an
idea of how to progress.* Read more about [[https://www.google.com/search?q=on+the+importance+of+reviwing+your+day+daily&oq=on+the+importance+of+reviwing+your+day+daily&aqs=chrome..69i57.367j0j7&sourceid=chrome&ie=UTF-8][the importance of reviewing your day on
a daily basis]].

Moreover, by journaling with Org on a daily basis, it can be relatively easy to
produce a report on what has been happening recently, at work for example. I'd
like to have multiple journals, for work and for personal life, as such I will
utilise a prefix argument to obtain my work specific entries.

Anyhow, the setup:
#+begin_src emacs-lisp
(defun my/org-journal-new-entry (prefix)
  "Open today‚Äôs journal file and start a new entry.

  With a prefix, we use the work journal; otherwise the personal journal."
  (interactive "P")
  (-let [org-journal-file-format (if prefix "Work-%Y-%m-%d" org-journal-file-format)]
    (org-journal-new-entry nil)
    (org-mode)
    (org-show-all)))

(use-package org-journal
  ;; C-u C-c j ‚áí Work journal ;; C-c C-j ‚áí Personal journal
  :bind (("C-c j" . my/org-journal-new-entry))
  :config
  (setq org-journal-dir         "~/Dropbox/journal/"
        org-journal-file-type   'yearly
        org-journal-file-format "Personal-%Y-%m-%d"))
#+end_src

Bindings available in ~org-journal-mode~, when journaling:
- ~C-c C-j~: Insert a new entry into the current journal file.
  - Note that keys for ~org-journal-new-entry~ shadow those for ~org-goto~.
- ~C-c C-s~: Search the journal for a string.
  - Note that keys for ~org-journal-search~ shadow those for ~org-schedule~.

All journal entries are registered in the Emacs Calendar.  To see available
journal entries do ~M-x calendar~.  Bindings available in the calendar-mode:

- ~j~: View an entry in a new buffer.
- ~i j~: ‚ÄòI‚Äônsert a new ‚Äòj‚Äôournal entry into the day‚Äôs file.
- ~f w/m/y/f/F~: ‚ÄòF‚Äôind, search, in all entries of the current week, month, year, all of time,
  of in all entries in the future.
** Workflow States
Here are some of my common workflow states, ---the ‚ÄòX/Y‚Äô indicates to do action ‚ÄòX‚Äô
when entering a state and ‚ÄòY‚Äô when leaving it, with ‚Äò!‚Äô denoting a timestamp
should be generated and ‚Äò@‚Äô denoting a user note should be made.
#+begin_src emacs-lisp
(setq org-todo-keywords
      '((sequence "TODO(t)" "STARTED(s@/!)" "|" "DONE(d/!)")
        (sequence "WAITING(w@/!)" "ON_HOLD(h@/!)" "|" "CANCELLED(c@/!)")))

;; Since DONE is a terminal state, it has no exit-action.
;; Let's explicitly indicate time should be noted.
(setq org-log-done 'time)
#+end_src

The ~@~ brings up a pop-up to make a local note about why the state changed.
*Super cool stuff!*

In particular, we transition from ~TODO~ to ~STARTED~ once 15 minutes, or a
reasonable amount, of work has transpired.  Since all but one state are marked
for logging, we could use the ~lognotestate~ logging facility of org-mode, which
prompts for a note every time a task‚Äôs state is changed.

Entering a comment about what I've done, even if it's very little, feels like
I'm getting something done. It's an explicit marker of progress and motivates me
to want to change my task's states more often until I see it marked ~DONE~.

Here's how they are coloured,
#+begin_src emacs-lisp
(setq org-todo-keyword-faces
      '(("TODO"      :foreground "red"          :weight bold)
        ("STARTED"   :foreground "blue"         :weight bold)
        ("DONE"      :foreground "forest green" :weight bold)
        ("WAITING"   :foreground "orange"       :weight bold)
        ("ON_HOLD"   :foreground "magenta"      :weight bold)
        ("CANCELLED" :foreground "forest green" :weight bold)))
#+end_src

Now we press ~C-c C-t~ then the letter shortcut to actually make the state of an org heading.
#+begin_src emacs-lisp
(setq org-use-fast-todo-selection t)
#+end_src

We can also change through states using Shift- left, or right.

Let's draw a state diagram to show what such a workflow looks like.

[[http://plantuml.com/index][PlantUML]] supports drawing diagrams in a tremendously simple format
---it even supports Graphviz/DOT directly and many other formats.
Super simple setup instructions can be found [[http://eschulte.github.io/babel-dev/DONE-integrate-plantuml-support.html][here]]; below are a bit more
involved instructions. Read the manual [[http://plantuml.com/guide][here]].

#+begin_src emacs-lisp
;; Install the tool
; (async-shell-command "brew cask install java") ;; Dependency
; (async-shell-command "brew install plantuml")

;; Tell emacs where it is.
;; E.g., (async-shell-command "find / -name plantuml.jar")
(setq org-plantuml-jar-path
      (expand-file-name "/usr/local/Cellar/plantuml/1.2019.13/libexec/plantuml.jar"))

;; Enable C-c C-c to generate diagrams from plantuml src blocks.
(add-to-list 'org-babel-load-languages '(plantuml . t) )
(require 'ob-plantuml)

; Use fundamental mode when editing plantuml blocks with C-c '
(add-to-list 'org-src-lang-modes '("plantuml" . fundamental))
#+end_src

Let's use this!

#+begin_src plantuml :file workflow.png :tangle no :exports both :eval never-export
skinparam defaultTextAlignment center  /' Text alignment '/

skinparam titleBorderRoundCorner 15
skinparam titleBorderThickness 2
skinparam titleBorderColor red
skinparam titleBackgroundColor Aqua-CadetBlue
title My Personal Task States

[*] -> Todo          /' This is my starting state '/
Done -right-> [*]    /' This is an end state      '/
Cancelled -up-> [*]  /' This is an end state      '/

/'A task is ‚ÄúTodo‚Äù, then it's ‚Äústarted‚Äù, then finally it's ‚Äúdone‚Äù. '/
Todo    -right-> Started
Started -down->  Waiting
Waiting -up->    Started
Started -right-> Done

/'Along the way, I may pause the task for some reason then
  return to it. This may be since I'm ‚ÄúBlocked‚Äù since I need
  something, or the task has been put on ‚Äúhold‚Äù since it may not
  be important right now, and it may be ‚Äúcancelled‚Äù eventually.
'/

Todo    -down-> Waiting
Waiting -up-> Todo
Waiting -up-> Done

Todo -down-> On_Hold
On_Hold -> Todo

On_Hold -down-> Cancelled
Waiting -down-> Cancelled
Todo    -down-> Cancelled

/' The Org-mode shortcuts for these states are as follows. '/
Todo      : t
On_Hold   : h
Started   : s
Waiting   : w
Cancelled : c
Done      : d

/' If a task is paused, we should document why this is the case. '/
note right  of Waiting:   Note what is\nblocking us.
note right  of Cancelled: Note reason\nfor cancellation.
note bottom of On_Hold:   Note reason\nfor reduced priority.

center footer  ‚ô•‚Äø‚ô• Org-mode is so cool (‚Ä¢ÃÄ·¥ó‚Ä¢ÃÅ)Ÿà
/' Note that we could omit the ‚Äúcenter, left, right‚Äù if we wished,
   or used a ‚Äúheader‚Äù instead.'/
#+end_src

#+results[be722b7f6a40cf685468918df82a3b22468e3d24]:
[[file:workflow.png]]

Of note:

- Multiline comments are with ~/' comment here '/~, single quote starts a one-line comment.

- Nodes don't need to be declared, and their names may contain spaces if they are enclosed in double-quotes.

- One forms an arrow between two nodes by writing a line with ~x ->[label here] y~
  or ~y <- x~; or using ~-->~ and ~<--~ for dashed lines. The label is optional.

  To enforce a particular layout, use ~-X->~ where ~X ‚àà {up, down, right, left}~.

- To declare that a node ~x~ has fields ~d, f~ we make two new lines having
  ~x : f~ and ~x : d~.

- One adds a note near a node ~x~ as follows: ~note right of x: words then newline\nthen more words~.

  Likewise for notes on the ~left, top, bottom~.

  - A note can be on several lines. It's terminated by ~end note~.

- Interesting sprites and many other things can be done with PlantUML. Read the docs.

This particular workflow is inspired by [[http://doc.norang.ca/org-mode.html][Bernt Hansen]] ---while quickly searching
through the PlantUML [[http://plantuml.com/guide][manual]]: The above is known as an ‚Äúactivity diagram‚Äù and
it's covered in ¬ß4.
** Clocking Work Time
Let's keep track of the time we spend working on tasks that we may have captured
for ourselves the previous day.  Such statistics provides a good idea of how
long it actually takes me to accomplish a certain task in the future and it lets
me know where my time has gone.

- Clock in :: on a heading with ~I~, or in the subtree with ~C-c C-x C-i~.
- Clock out :: of a heading with ~O~, or in the subtree with ~C-c C-x C-o~.
- Clock report :: See clocked times with ~C-c C-x C-r~.

After clocking out, the start and end times, as well as the elapsed time, are
added to a drawer to the heading. We can punch in and out of tasks as many times
as desired, say we took a break or switched to another task, and they will all
be recorded into the drawer.

#+begin_src emacs-lisp
;; Record a note on what was accomplished when clocking out of an item.
(setq org-log-note-clock-out t)
#+end_src

To get started, we could estimate how long a task will take and clock-in; then
clock-out and see how long it actually took.

Moreover, we can overlay due dates and priorities to tasks in a non-intrusive
way that is easy to edit by hand.

#+begin_src emacs-lisp
;; List of all the files & directories where todo items can be found. Only one
;; for now: My default notes file.
(setq org-agenda-files (list org-default-notes-file))

;; How many days ahead the default agenda view should look
(setq org-agenda-ndays 7)

;; How many days early a deadline item will begin showing up in your agenda list.
(setq org-deadline-warning-days 14)

;; In the agenda view, days that have no associated tasks will still have a line showing the date.
(setq org-agenda-show-all-dates t)

;; Scheduled items marked as complete will not show up in your agenda view.
(setq org-agenda-skip-scheduled-if-done t)
(setq org-agenda-skip-deadline-if-done  t)
#+end_src

The agenda view ‚Äì--even in the 7-days-at-a-time view--‚Äì will always begin on the
current day.  This is important, since while using org-mode as a day planner,
you never want to think of days gone past. That‚Äôs something you do in other
ways, such as when reviewing completed tasks.
#+begin_src emacs-lisp
(setq org-agenda-start-on-weekday nil)
#+end_src

Sometimes, at the beginning at least, I would accidentally invoke the transposed
command ~C-x C-c~, which saves all buffers and quits Emacs. So here's a helpful
way to ensure I don't quit Emacs accidentally.
#+begin_src emacs-lisp
(setq confirm-kill-emacs 'yes-or-no-p)
#+end_src

A few more settings:
#+begin_src emacs-lisp
;; Resume clocking task when emacs is restarted
(org-clock-persistence-insinuate)

;; Show lot of clocking history
(setq org-clock-history-length 23)

;; Resume clocking task on clock-in if the clock is open
(setq org-clock-in-resume t)

;; Sometimes I change tasks I'm clocking quickly ---this removes clocked tasks with 0:00 duration
(setq org-clock-out-remove-zero-time-clocks t)

;; Clock out when moving task to a done state
(setq org-clock-out-when-done t)

;; Save the running clock and all clock history when exiting Emacs, load it on startup
(setq org-clock-persist t)

;; Do not prompt to resume an active clock
(setq org-clock-persist-query-resume nil)

;; Include current clocking task in clock reports
(setq org-clock-report-include-clocking-task t)
#+end_src

*** Finding tasks to clock in
Use one of the following options, with the top-most being the first to be tried.
- From anywhere, ~C-u C-c C-x C-i~ yields a pop-up for recently clocked in tasks.
- Pick something off today's agenda scheduled items.
- Pick a ~Started~ task from the agenda view, work on this unfinished task.
- Pick something from the ~TODO~ tasks list in the agenda view.

~C-c C-x C-d~ also provides a quick summary of clocked time for the current org file.

*** Estimates versus actual time
Before clocking into a task, add to the properties drawer ~:Effort: 1:25~ or ~C-c
C-x C-e~, for a task that you estimate will take an hour and twenty-five minutes,
for example. Now the modeline will mention the time elapsed alongside the task
name. *Woah!*
- This is also useful when you simply want to put a time limit on a task that
  wont be completed anytime soon, say writing a thesis or a long article, but
  you still want to work on it for an hour a day and be warned when you exceed
  such a time constraint.

  When you've gone above your estimate time, the modeline colours it red.

* Programming
Herein we configure utilites for version control, function and variable lookup,
and template expansion for inescapably repetitive scenarios.

** Highlight defined Lisp symbols
Usually Emacs only highlights macro names, the [[https://github.com/Fanael/highlight-defined][following]] incantation makes it
highlight all defined names ---as long as we're in Lisp mode, whence in org-src
blocks we use ~C-c '~.
#+begin_src emacs-lisp
;; Emacs Lisp specific
(use-package highlight-defined
  :hook (emacs-lisp-mode . highlight-defined-mode))
#+end_src

Super helpful in making my Emacs configuration: If a name is not highlighted,
then I've misspelled it or it doesn't exist! :smile:

** Eldoc for Lisp and Haskell
In =emacs-lisp-mode= we can enable =eldoc-mode= to display information
about a function or a variable in the echo area. Likewise for Haskell.

#+begin_src emacs-lisp
(add-hook 'emacs-lisp-mode-hook       'turn-on-eldoc-mode)
(add-hook 'lisp-interaction-mode-hook 'turn-on-eldoc-mode)
(add-hook 'haskell-mode-hook          'turn-on-haskell-doc-mode)
(add-hook 'haskell-mode-hook          'turn-on-haskell-indent)
#+end_src

The less casual Haskeller would likely want to use [[https://haskell-lang.org/intero][intero]] to obtain
more support; e.g., obtain suggestions from GHC about redundant imports
or type signatures.

The more

** Jumping to definitions & references
Out-of-the-box Emacs has ‚Äòxref‚Äô utilities ~M-.~ and ~C-u M-.~ to [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Xref.html#Xref][Find Identifier
References]]; however, tags to source definitions need to be generated using the
=etags= program. Nonetheless, the xref utilites are impressive and some just work:
For example, ~M-?~ cleverly finds /all/ references for an identifier in ‚Äònear by‚Äô
files; whereas ~C-u M-. RET my/.*~, for example, uses the given regular expression
to list all identifiers with prefix ~my/~, thereby listing my personally defined
names ^_^

| =C-M-. ùìáùìÆ‚ÑäùìÆùìç= | Find all identifiers whose name matches the given pattern |

Let's get [[https://github.com/jacktasia/dumb-jump][dumb-jump]], where the ‚Äòdumb‚Äô is possibly due to the fact
that it works by brute-force regular-expression lookup of
pre-defined ‚Äòdefinitional template‚Äô rules. It ‚Äújust works‚Äù ^_^
#+begin_src emacs-lisp
(use-package dumb-jump
  :bind (("M-g q"     . dumb-jump-quick-look) ;; Show me in a tooltip.
         ("M-g ."     . dumb-jump-go-other-window)
         ("M-g b"     . dumb-jump-back)
         ("M-g p"     . dumb-jump-go-prompt)
         ("M-g a"     . xref-find-apropos)) ;; aka C-M-.
  :config
  ;; If source file is visible, just shift focus to it.
  (setq dumb-jump-use-visible-window t))
#+end_src

In Lisp, for binding macros, it lists all possible mentions of the bound
variable ---the first is likely what is desired.  Alternatively, one could just
add the necessary rule to the variable =dumb-jump-find-rules=.  Otherwise, it
works fine even for locally bound definitions.  It works depending on the
extension of a file.
** Aggressive Indentation
With a single space or tab, my code should always remain indented.
#+begin_src emacs-lisp
;; Always stay indented: Automatically have blocks reindented after every change.
(use-package aggressive-indent
  :config (global-aggressive-indent-mode t))

;; Use 4 spaces in places of tabs when indenting.
(setq-default indent-tabs-mode nil)
(setq-default tab-width 4)
#+end_src

** What's changed & who's to blame?
Let's have, in a fringe, an indicator for altered regions in a version
controlled file.  The symbols ‚Äú+, =‚Äù appear in a fringe by default for
alterations ---we may change these if we like.

#+begin_src emacs-lisp
;; Hunk navigation and commiting.
(use-package git-gutter
  :diminish
  :config (global-git-gutter-mode))
;; Diff updates happen in real time according when user is idle.
#+end_src

Let's set a hydra so we can press ~C-x v n n p n~ to move the next two
altered hunks, move back one, then move to the next. This saves me having
to supply the prefix ~C-x v~ each time I navigate among my alterations.
At any point we may also press ~u ùï©~ to denote ~C-u ‚ü™prefix‚ü´ ùï©~.
#+begin_src emacs-lisp
(defhydra hydra-version-control (global-map "C-x v")
  "Version control"
  ;; Syntax: (extension method description)
  ("n" git-gutter:next-hunk      "Next hunk")
  ("p" git-gutter:previous-hunk  "Previous hunk")
  ("d" git-gutter:popup-hunk     "Show hunk diff")
  ("r" git-gutter:revert-hunk    "Revert hunk\n")
  ("c" git-gutter:stage-hunk     "Stage hunk")
  ("s" git-gutter:statistic      "How many added & deleted lines"))
#+end_src

Commiting with ~C-x v c~ let's us use ~C-c C-k~ to cancel and ~C-c C-c~ to
submit the given message; ~C-c C-a~ to amend the previous commit.

Alternatively, we may use [[https://github.com/dgutov/diff-hl][diff-hl]]:
#+begin_src emacs-lisp
;; Colour fringe to indicate alterations.
;; (use-package diff-hl)
;; (global-diff-hl-mode)
#+end_src

A few more helpful version control features:
#+begin_src emacs-lisp
;; Popup for who's to blame for alterations.
(use-package git-messenger
  :config ;; Always show who authored the commit and when.
          (setq git-messenger:show-detail t)
          ;; Message menu let's us use magit diff to see the commit change.
          (setq git-messenger:use-magit-popup t))

;; View current file in browser on github.
;; More generic is ‚Äúbrowse-at-remote‚Äù.
(use-package github-browse-file)

;; Add these to the version control hydra.
;;
(defhydra hydra-version-control (global-map "C-x v")
  ("b" git-messenger:popup-message "Who's to blame?")
  ;; C-u C-x b ‚ï± u b ‚à∑ Also show who authored the change and when.
  ("g" github-browse-file-blame "Show file in browser in github")
  ("s" magit-status "Git status of current buffer"))
#+end_src

Perhaps ~C-x v b~ will motivate smaller, frequent, commits.

Obtaining URL links to the current location of a file
---URLs are added to the kill ring.
Usefully, if [[https://gitlab.com/pidu/git-timemachine][git-timemachine-mode]] is active, the generated link
points to the version of the file being visited.
#+begin_src emacs-lisp
(use-package git-link)

(defhydra hydra-version-control (global-map "C-x v")
  ("l" git-link "Git URL for current location"))
#+end_src

Read [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Version-Control.html#Version-Control][here]] for more about version control in general.

** Highlighting TODO-s & Showing them in Magit
Basic support todos. By default these include: TODO NEXT THEM PROG OKAY DONT
FAIL DONE NOTE KLUDGE HACK TEMP FIXME and any sequence of X's or ?'s of length
at least 3: XXX, XXXX, XXXXX, ‚Ä¶, ???, ????, ????, ‚Ä¶.
#+begin_src emacs-lisp
;; NOTE that the highlighting works even in comments.
(use-package hl-todo
  :init (global-hl-todo-mode)   ;; Enable it everywhere.
  :config
  ;; Adding new keywords
  (loop for kw in '("TEST" "MA" "WK" "JC")
        do (add-to-list 'hl-todo-keyword-faces (cons kw "#dc8cc3"))))
#+end_src

Lest these get buried in mountains of text, let's have them [[https://github.com/alphapapa/magit-todos][become
mentioned]] in a magit status buffer ---which uses the keywords from ~hl-todo~.
#+begin_src emacs-lisp
;; MA: The todo keywords work in code too!
(use-package magit-todos
  :after magit
  :after hl-todo
  :config
  ;; For some reason cannot use :custom with this package.
  (custom-set-variables
    '(magit-todos-keywords (list "TODO" "FIXME" "MA" "WK" "JC")))
  ;; Ignore TODOs mentioned in exported HTML files; they're duplicated from org src.
  (setq magit-todos-exclude-globs '("*.html"))
  (magit-todos-mode))
#+end_src

Note that such TODO keywords are not propagated from sections that are
COMMENT-ed out in org-mode.

Open a Magit status buffer, or run ~magit-todos-list~ to show a dedicated to-do
list buffer. You can then peek at items with space, or jump to them with enter.

Seeing the TODO list with each commit is an incentive to actually tackle the
items there (‚Ä¢ÃÄ·¥ó‚Ä¢ÃÅ)Ÿà

- Ensure you exclude generated files, such as the Emacs backups directory,
  from being consulte. Using ~magit~, press ~i~ to mark items to be ignored.
- This feature also works outside of git repos.

Add these to the version control hydra.
#+begin_src emacs-lisp
(defhydra hydra-version-control (global-map "C-x v")
  ("t" helm-magit-todos "Show TODOs lists for this repo."))
#+end_src

** On the fly syntax checking
[[https://www.flycheck.org/en/latest/][Flycheck]] is a on-the-fly syntax checker that relies on external programs to
check buffers; which must be installed separately.

- E.g., ghc is required for Haskell; whereas Emacs Lisp is checked by Emacs'
  own byte compiler, ~emacs-lisp~.
- Sometimes more than one checking tool applies, use ~C-c ! s~ to select a
  different checker.
- =C-c ! n,p,l= takes you to the ‚Äòn‚Äôext or ‚Äòp‚Äôrevious
  error, or ‚Äòl‚Äôist all errors in another buffer.

  ~C-c ! c~ to explicitly recheck the buffer.

#+begin_src emacs-lisp
(use-package flycheck
  :diminish
  :init (global-flycheck-mode)
  :config ;; There may be multiple tools; I have GHC not Stack, so let's avoid that.
  (setq-default flycheck-disabled-checkers '(haskell-stack-ghc emacs-lisp-checkdoc))
  :custom (flycheck-display-errors-delay .3))
#+end_src

In an org-src block, we press ~C-c '~ to get into the language's mode where
flycheck will provide warnings.
#+begin_src haskell :tangle no
module Main where

main :: IO ()
main = putStrLn $ "nice" ++ f 0

f :: Int -> String
f x = x -- show x
-- type error
#+end_src

In-general, flycheck is intended for self-contained raw code ---not for source
blocks in Org-mode. Whence, the above example is a complete Haskell program,
with a named module and ~main~ method.

I think the built-in [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Flymake.html][flymake]] syntax checker is better for Emacs Lisp,
so let's use that for ELisp.
#+begin_src emacs-lisp
(use-package flymake
  :hook ((emacs-lisp-mode . (lambda () (flycheck-mode -1)))
         (emacs-lisp-mode . flymake-mode))
  :bind (:map flymake-mode-map
              ("C-c ! n" . flymake-goto-next-error)
              ("C-c ! p" . flymake-goto-prev-error)))
#+end_src

Try it out:
#+begin_src emacs-lisp :tangle no
(setq 1 2) ;; Error: ‚Äò1‚Äô is not a variable.
#+end_src

** Coding with a Fruit Salad: Semantic Highlighting
What should be highlighted when we write code? Static keywords with fixed uses,
or dynamic user-defined names?

- /Syntax/ highlighting ‚á® Specific words are highlighted in strong colours so that
  the /structure/ can be easily gleaned.
  - Generally this only includes a language's keywords, such as ~if, loop, begin,
        end, cond~.
  - User defined names generally share one colour; usually black.
  - Hence, an ~if~ block may be seen as one coloured keyword followed by
    a blob of black text.

  /Obvious keywords are highlighted while the rest remains in black!/

- /Semantic/ highlighting ‚á® Identifiers obtain unique colouring.
  - This makes it much easier to visually spot dependencies with a quick glance.
    - One can *see* how data flows through a function.
  - In dynamic languages, this is a visual form of typing: Different colours are
    for different names.
    - Especially helpful for (library) names that are almost the same.
    - This can be accomplished anywhere in Emacs by pressing ~M-s h .~ on
      a selected phrase.

For Emacs, [[https://github.com/ankurdave/color-identifiers-mode][Color Identifiers Mode]] gives unique highlighting to identifiers.
- It comes with support for a bunch of languages, and one can add support for others.
- It picks colours adaptively to fit the theme; one uses ~M-x color-identifiers:regenerate-colors~ after a theme change.

#+begin_src emacs-lisp
(use-package color-identifiers-mode
  :config (global-color-identifiers-mode))
#+end_src

When writing a new name, after about ~5 seconds it obtains a colour which is then
propagated immediately to any new occurrences. This timeout before recolouring
is to avoid any lag from multithreading and can be changed by altering the following
line (#64) in the source file, changing the ~5~ to a smaller number.
#+begin_src emacs-lisp :tangle no
(run-with-idle-timer 5 t 'color-identifiers:refresh)
#+end_src

Here are further reads:
- [[https://medium.com/@evnbr/coding-in-color-3a6db2743a1e][Coding in color: How to make syntax highlighting more useful]] ---an excellent, terse, read
- [[https://zwabel.wordpress.com/2009/01/08/c-ide-evolution-from-syntax-highlighting-to-semantic-highlighting/][C++ IDE Evolution: From Syntax Highlighting to Semantic Highlighting]]
  - Names with a similar prefix share a colour, and class-local items share a colour.
- [[https://wordsandbuttons.online/lexical_differential_highlighting_instead_of_syntax_highlighting.html][Lexical differential highlighting instead of syntax highlighting]]
  - /Ideally, the smaller the lexical difference, the greater the color difference should be./
- [[https://github.com/jacksonrayhamilton/context-coloring][Colouring by Context]] ---an Emacs package
- [[http://www.linusakesson.net/programming/syntaxhighlighting/][A case against syntax highlighting]]

** Text Folding with [[https://github.com/gregsexton/origami.el][Origami-mode]]
Literate programming within Org-mode is not always ideal, so we use a
programming mode directly and then may want to have arbitrary ‚Äòsections‚Äô of text
folded up.  Let's describe how to accomplish this goal.

We use a feature-full folding mode.
#+begin_src emacs-lisp
(use-package origami)
#+end_src

With basic support for one of my languages.
#+begin_src emacs-lisp
(push (cons 'agda2-mode (origami-markers-parser "{-" "-}"))
      origami-parser-alist)
#+end_src

With expected support for searching.
#+begin_src emacs-lisp
(defun my/search-hook-function ()
  (when origami-mode (origami-toggle-node (current-buffer) (point))))

;; Open folded nodes if a search stops there.
(add-hook 'helm-swoop-after-goto-line-action-hook #'my/search-hook-function)
;;
;; Likewise for incremental search, isearch, users.
;; (add-hook 'isearch-mode-end-hook #'my/search-hook-function)
#+end_src

Along with a hydra for super quick navigation and easily folding, unfolding
blocks! Love this one ^_^
#+begin_src emacs-lisp
(defhydra folding-with-origami-mode (global-map "C-c f")
  ("h" origami-close-node-recursively "Hide")
  ("o" origami-open-node-recursively  "Open")
  ("t" origami-toggle-all-nodes  "Toggle buffer")
  ("n" origami-next-fold "Next")
  ("p" origami-previous-fold "Previous"))
#+end_src


** Jump between windows using Cmd+Arrow & between recent buffers with Meta-Tab
We can use ~C-x o~ to switch to the ‚Äòo‚Äôther window, and ~C-u ùìÉ C-x o~ to switch to
the ùìÉ-th next clockwise window, but using ~s-‚Üë,‚Üì,‚Üê,‚Üí~ may be faster.

#+begin_src emacs-lisp
(use-package windmove
  :config ;; use command key on Mac
          (windmove-default-keybindings 'super)
          ;; wrap around at edges
          (setq windmove-wrap-around t))
#+end_src

The [[https://github.com/killdash9/buffer-flip.el][docs]], for the following, have usage examples.
#+begin_src emacs-lisp
(use-package buffer-flip
  :bind
   (:map buffer-flip-map
    ("M-<tab>"   . buffer-flip-forward)
    ("M-S-<tab>" . buffer-flip-backward)
    ("C-g"       . buffer-flip-abort))
  :config
    (setq buffer-flip-skip-patterns
        '("^\\*helm\\b")))
;; key to begin cycling buffers.
(global-set-key (kbd "M-<tab>") 'buffer-flip)
#+end_src

See [[https://www.emacswiki.org/emacs/buffer-move.el][buffer-move]] if you're interested in moving the buffers, and their windows,
into new configurations.

** Snippets ---Template Expansion
It is common that there is a sequence of text that we tend to repeat
often, possibly with a name or some other parameter altered.
Such a ‚Äòsnippet‚Äô could be written once then provided by a simple
Lisp insert command with the parameters being queried. Luckily, others
have written such pleasant utilities.

[[http://joaotavora.github.io/yasnippet/snippet-development.html][Yasnippet]] is a pleasant utility for template expansion with the alluring
feature to allow arbitrary Lisp code to be executed during expansion.
The declaration of templates is verbose, requiring a particular file
hierarchy, as such I utilise [[https://github.com/Kungsgeten/yankpad][Yankpad]] which allows me to employ
an Org-mode approach: Each template corresponds to an org heading of
the form ~Key:Words:For:Expansion:Here: name of snippet here~ and the
template body is then the body of the org heading.
Any of ~Key, Words, For, Expansion, Here~ will rewrite into the body
of the org tree. This is much more terse, and I even don't bother
with that; instead preferring to tangle my templates using yankpad
as a mere interface. It is important to note that Yankpad also provides
features that are not in Yassnippet, such as allowing arbitrary language
code to be executed ---one simply uses an org-src block!

There are only be one major completion backend for any mode, but
other backends can serve as secondary ones. Here's a function to
make ~company-yankpad~ a secondary of all existing backends.
#+begin_src emacs-lisp
;; Add yasnippet support for all company backends
;;
(cl-defun my/company-backend-with-yankpad (backend)
  "There can only be one main completition backend, so let's
   enable yasnippet/yankpad as a secondary for all completion
   backends.

   Src: https://emacs.stackexchange.com/a/10520/10352"

  (if (and (listp backend) (member 'company-yankpad backend))
      backend
    (append (if (consp backend) backend (list backend))
            '(:with company-yankpad))))
#+end_src

#+begin_src emacs-lisp
;; Yet another snippet extension program
(use-package yasnippet
  :diminish yas-minor-mode
  :config
    (yas-global-mode 1) ;; Always have this on for when using yasnippet syntax within yankpad
    ;; respect the spacing in my snippet declarations
    (setq yas-indent-line 'fixed))

;; Alternative, Org-based extension program
(use-package yankpad
  :diminish
  :config
    ;; Location of templates
    (setq yankpad-file "~/.emacs.d/yankpad.org")

    ;; Ignore major mode, always use defaults.
    ;; Yankpad will freeze if no org heading has the name of the given category.
    (setq yankpad-category "Default")

    ;; Load the snippet templates ---useful after yankpad is altered
    (yankpad-reload)

    ;; Set company-backend as a secondary completion backend to all existing backends.
    (setq company-backends (mapcar #'my/company-backend-with-yankpad company-backends)))
#+end_src

With these settings, along with the ~company~ backend, I may type a keyword then
‚Äútab‚Äù it into expansion.

Yankpad requires we have an org file that contains our templates, so we tangle
such a file ~~/.emacs.d/yankpad.org~, and have all of our templates be globally
accessible.
#+begin_src org :tangle "~/.emacs.d/yankpad.org"  :comments none
,#+Description: This is file is generated from my init.org; do not edit.

,* Default                                           :global:
#+end_src

Here's an example of a common template I perform by hand ---no more!
I have the expected habit of copying a URL from someplace then forming
a link to it by writing ~[[URL] [description]]~, since the URL & syntax are already
known, let's expand those and place the cursour at the only unknown ---the description.
#+begin_src org :tangle "~/.emacs.d/yankpad.org" :comments none
,** my-org-insert-link: cleverly insert a link copied to clipboard
 [[${1:`(clipboard-yank)`}][$2]] $0
#+end_src

What's going on here?
1. This template is expanded with the keyword ~my-org-insert-link~, then ‚Äútab‚Äù.
2. The cursour lands at position ~$1~, which has default text being the result
   of evaluating ~(clipboard-yank)~.

   We may evaluate Lisp code anywhere by enclosing it in backticks.

3. If we're satisfied with the current field, we simply tab to the next field.
   Otherwise, we simply write text --which overwrites the default text.

4. After enough tabbing we complete the template and the cursour lands
   at position ~$0~.

‚ü™ Having default or mirrored text for ~$2~ would not allow me to see the URL
field, lest I wish to change it or at least confirm it's what I want.
Hence, the ~$2~ field has no default. ‚ü´

Let's overwrite the usual way to insert such links, via ~C-c C-l~.
#+begin_src emacs-lisp
(cl-defun org-insert-link ()
  "Makes an org link by inserting the URL copied to clipboard and
  prompting for the link description only.

  Type over the shown link to change it, or tab to move to the
  description field.

  This overrides Org-mode's built-in ‚Äòorg-insert-link‚Äô utility;
  whence C-c C-l uses the snippet."
  (interactive)
  (insert "my-org-insert-link")
  (yankpad-expand))
#+end_src

The [[http://joaotavora.github.io/yasnippet/snippet-development.html][Yasnippet manual]] is an accessible read, as is the [[https://github.com/Kungsgeten/yankpad][Yankpad manual]], and
 showcases many other utilities; such as having certain snippets being
 enabled only in particular modes or on demand. Of note is that field ~$n~ can be
 accessed in code with the invocation ~(yas-field-value n)~.

The rest of this section is other templates, not much for now,
concluding with actually loading this snippet mechanism globally.

The remaining subsections discuss contents of my yankpad file.

*** Org-mode Templates ---A reason I ‚Äúgenerate‚Äù templates ;)
This produces a pop-up list of org-mode block types, if ~src~ is selected, then a
list of my commonly used languages pops-up.  Alternatively, ignore the pop-up
menu and write any block or language name.
#+begin_src org :tangle "~/.emacs.d/yankpad.org"  :comments none
,** begin: produce an org-mode block
,#+begin_${1:environment$(let*
    ((block '("src" "example" "quote" "verse" "center" "latex" "html" "ascii"))
     (langs '("c" "emacs-lisp" "lisp" "latex" "python" "sh" "haskell" "plantuml" "prolog"))
     (type (yas-choose-value block)))
     (concat type (when (equal type "src") (concat " " (yas-choose-value langs)))))}
 $0
,#+end_${1:$(car (split-string yas-text))}
#+end_src
In this case, ~yas-text~ is equivalent to (~yas-field-value 1)~;
it generally refers to the value of the field being mirrored with ~${n: ‚ãØyas-text‚ãØ}~.

However, going through pop-ups takes precious time ---besides being slightly annyoing.
Let's introduce a template for my most utilised kind of language blocks.
#+begin_example
,** s_org: src block for org
,#+begin_src org
$0
,#+end_src
#+end_example

However, doing this for each language I want is a waste of time and textual
space. Why? The purpose of templates is to reduce repetition, yet the above
block would be repeated with only 3 parts ‚Äòunknown‚Äô: The expansion keyword, the
description, and the org-mode source block name.  Whence, the template /text/ is
generated by the following basic loop ---whose source block is named
~my-org-lang-templates~.
#+name: my-org-lang-templates
#+begin_src emacs-lisp :tangle no :wrap "src org :tangle ~/.emacs.d/yankpad.org" :exports code :results replace drawer
;; We make an org BLOCK snippet template for each LANG the user has declared.
;;
(loop for (shortcut . block) in '(("s_" . "src")
                                  ("e_" . "example")
                                  ("q_" . "quote")
                                  ("v_" . "verse")
                                  ("c_" . "center")
                                  ("ex_" . "export"))
      concat (loop for lang in (-cons* "org" "agda2" "any" ;; Extra ‚Äòlanguages‚Äô
                                       ;; Also include whatever languages we've loaded for literate programming.
                                       (--map (symbol-name (car it)) org-babel-load-languages))
                   for key         = (concat shortcut lang)
                   for description = (concat block " block for " lang)
                   concat (concat "\n** " key ": " description
                                  "\n#+begin_" block " " lang
                                  "\n$0"
                                  "\n#+end_" block "\n")))
#+end_src

The /resulting text/ of this block, generated below, is tangled to our yankpad
by utilising a [[https://www.gnu.org/software/emacs/manual/html_node/org/Noweb-reference-syntax.html][noweb]] source block invocation. An example of the
resulting text is the above ‚Äús_org‚Äù block. The result is *83* template expansions
---that would have been a bit much to write by hand.
#+begin_example org
,#+begin_src org :tangle "~/.emacs.d/yankpad.org" :noweb yes
<<my-org-lang-templates()>>
,#+end_src
#+end_example

Now ~s_~, due to company mode, brings up a list of languages that I can then
scroll down through, then ‚Äúenter‚Äù upon to expand. Moreover, the prefix ~s_~ means
that the key is mostly irrelevant, since I needn't remember it because
company-mode immediately lists possible completions /along/ with the /descriptions/
for the snippets. Likewise for examples with ~e_~ or quotes with ~q_~.  Super neat
stuff :-)

Ain't this reminiscent of meta-programming ;-)

Using =noweb= invocations, any time the tangling is performed, the yankpad
is kept up to date --no personal intervention from myself.

*** Elisp Templates
The following snippets were rather useful as I began learning Lisp to construct
my editor of choice ---I love Emacs so much. Admittedly, I still need the first
one below and usually beat around the bush by using ~(loop for ‚ãØ do ‚ãØ)~, which is
‚Äònoisier‚Äô but easier to remember and to read for non-Lispers.
#+begin_src org :tangle "~/.emacs.d/yankpad.org"  :comments none
,** loop:  Elisp's for each loop
(dolist (${1:var} ${2:list-form})
        ${3:body})

,** defun: Lisp functions
(cl-defun ${1:fun-name} (${2:arguments})
  "${3:documentation}"
  $0
)

,** cond: Elisp conditionals
(cond (${1:scenario‚ÇÅ} ${2:response‚ÇÅ})
      (${3:scenario‚ÇÇ} ${4:response‚ÇÇ})
)
#+end_src

*** Equational Templates
To show ~‚Ñí = ‚Ñõ~, one starts at the complicated side, say /‚Ñí/, then, with the aim of
simplification, tries to end at the simpler side, /ùì°/.  Along the way, one
justifies each step of the calculation. This approach is popular in the proof
assistant Agda; [[https://alhassy.github.io/PathCat/][Examples]]. Read more about [[http://www.mathmeth.com/][informal calculational proofs]].

#+begin_src org :tangle "~/.emacs.d/yankpad.org"  :comments none
,** fun: Function declaration with type signature

${1:fun-name} : ${2:arguments}
$1 ${3:args} = ?$0

,** eqn_begin: Start a ‚â°-Reasoning block in Agda

begin
  ${1:complicated-side}
$0‚â°‚ü® ${3:reason-for-the-equality} ‚ü©
 ${2:simpler-side}
‚àé

,** eqn_step: Insert a step in a ‚â°-Reasoning block in Agda
‚â°‚ü® ${2:reason-for-the-equality} ‚ü©
  ${1:new-expression}
$0
#+end_src

One expands ~eqn_begin~, tabs to fill in the three main locations, then
/immediately/ types ~eqn_step~ to produce a new step in a calculational proof.

*** Re-Enabling Templates
After our yankpad templates are generated, we need to load it.
#+begin_src emacs-lisp
;; After init hook; see above near use-package install.
(yankpad-reload)
#+end_src
* Helpful Utilities & Shortcuts
Here is a collection of Emacs-lisp functions that I have come to use in other files.

Disclaimer: I wrote much of the following /before/ I learned any lisp; everything below is probably terrible.

Let's save a few precious seconds,
#+begin_src emacs-lisp
;; change all prompts to y or n
(fset 'yes-or-no-p 'y-or-n-p)

;; Enable all ‚Äòpossibly confusing commands‚Äô such as helpful but
;; initially-worrisome ‚Äúnarrow-to-region‚Äù, C-x n n.
(setq-default disabled-command-function nil)
#+end_src

** Documentation Pop-Ups
Let [[https://github.com/expez/company-quickhelp][documentation pop-up]] when we pause on a completion.
This is very useful when editing in a particular coding language, say via
~C-c '~ for org-src blocks.
#+begin_src emacs-lisp
(use-package company-quickhelp
 :config
   (setq company-quickhelp-delay 0.1)
   (company-quickhelp-mode))
#+end_src
** Emacs keybindings for my browser                                :Disabled:
#+begin_center
‚ü® I was a bit too Emacs-happy at one-point; this' cool, but I rarely use it;
except ~C-x b~: A buffer approach is far superior to a tab-based one. ‚ü©
#+end_center

I've downloaded the [[https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb/related][Vimium]] extension for Google Chrome,
and have copy-pasted [[https://gist.github.com/dmgerman/6f0e5f9ffc6484dfaf53][these]] Emacs key bindings into it.
Now ~C-h~ in my browser shows which Emacs-like bindings
can be used to navigate my browser ^_^

** Using Emacs in any text area on my OS                           :Disabled:
#+begin_center
‚ü® I was a bit too Emacs-happy at one-point; this' cool, but I rarely use it. ‚ü©
#+end_center

Using the [[https://github.com/zachcurry/emacs-anywhere/#usage][Emacs-Anywhere]] tool, I can press ~Cmd Shift e~ to have an Emacs frame
appear, produce text with Emacs editing capabilities, then ~C-x 5 0~ to have the
resulting text dumped into the text area I was working in.

This way I can use Emacs literally anywhere for textual input!

For my Mac OSX:
#+begin_src emacs-lisp :tangle no
(shell-command "curl -fsSL https://raw.github.com/zachcurry/emacs-anywhere/master/install | bash")

(server-start)
#+end_src

The tools that use emacs-anywhere ---such as my web browser--- and emacs-anywhere
itself need to be given sufficient OS permissions:
#+begin_example org
System Preferences ‚Üí Security & Privacy ‚Üí Accessibility
#+end_example
Then check the emacs-anywhere box from the following gui and provide a keyboard shortcut:
#+begin_example org
System Preferences ‚Üí Keyboard ‚Üí Shortcuts ‚Üí Services
#+end_example

(‚Ä¢ÃÄ·¥ó‚Ä¢ÃÅ)Ÿà

I always want to be in Org-mode and input unicode:
#+begin_src elisp :tangle no
(add-hook 'ea-popup-hook
  (lambda (app-name window-title x y w h)
    (org-mode)
    (set-input-method "Agda")))
#+end_src

** Reload buffer with ~f5~
I do this so often it's not even funny.
#+begin_src emacs-lisp
(global-set-key [f5] '(lambda () (interactive) (revert-buffer nil t nil)))
#+end_src

In Mac OS, one uses ~Cmd-r~ to reload a page and Emacs binds buffer reversion to ~Cmd-u~
--in Emacs, Mac's ~Cmd~ is referred to as the ‚Äòsuper key‚Äô and denoted ~s~.

Moreover, since I use Org-mode to generate code blocks and occasionally
inspect them, it would be nice if they automatically reverted when they
were regenerated --Emacs should also prompt me if I make any changes!

#+begin_src emacs-lisp
;; Auto update buffers that change on disk.
;; Will be prompted if there are changes that could be lost.
(global-auto-revert-mode 1)

;; Don't show me the ‚ÄúARev‚Äù marker in the mode line
(diminish 'auto-revert-mode)
#+end_src

** Kill to start of line
Dual to ~C-k~,
#+begin_src emacs-lisp
;; M-k kills to the left
(global-set-key "\M-k" '(lambda () (interactive) (kill-line 0)) )
#+end_src
** Killing buffers & windows: ~C-x k~ has a family
Let's extend the standard ~C-x k~ with prefix support, so that we can invoke
variations: Kill /this/ buffer, kill /other/ buffer, or kill /all other/ buffers.

By default ~C-x k~ prompts to select which buffer should be selected. I almost
always want to kill the current buffer, so let's not waste time making such a
tedious decision. Moreover, if I've killed a buffer, I usually also don't want
the residual window, so let's get rid of it.
#+begin_src emacs-lisp
(global-set-key (kbd "C-x k")
  (lambda (&optional prefix)
"C-x k     ‚áí Kill current buffer & window
C-u C-x k ‚áí Kill OTHER window and its buffer
C-u C-u C-x C-k ‚áí Kill all other buffers and windows

Prompt only if there are unsaved changes."
     (interactive "P")
     (pcase (or (car prefix) 0)
       ;; C-x k     ‚áí Kill current buffer & window
       (0  (kill-this-buffer)
           (unless (one-window-p) (delete-window)))
       ;; C-u C-x k ‚áí Kill OTHER window and its buffer
       (4  (other-window 1)
           (kill-this-buffer)
           (unless (one-window-p) (delete-window)))
       ;; C-u C-u C-x C-k ‚áí Kill all other buffers and windows
       (16   (mapc 'kill-buffer (delq (current-buffer) (buffer-list)))
             (delete-other-windows)))))
#+end_src

The incantation ~C-u C-x k~ will reduce the noise of all the documentation buffers
I tend to consult.

** Switching from 2 horizontal windows to 2 vertical windows
I often find myself switching from a horizontal view of two windows in Emacs to a
vertical view. This requires a variation of ~C-x 1 RET C-x 3 RET C-x o C-x b RET~.
Instead I now only need to type ~C-|~ to make this switch.
#+begin_src emacs-lisp
(defun ensure-two-vertical-windows ()
  "I used this method often when programming in Coq.

When there are two vertical windows, this method ensures the left-most
window contains the buffer with the cursour in it."
  (interactive)
  (let ((otherBuffer (buffer-name)))
    (other-window 1)                ;; C-x 0
    (delete-window)                 ;; C-x 0
    (split-window-right)			;; C-x 3
    (other-window 1)                ;; C-x 0
    (switch-to-buffer otherBuffer)	;; C-x b RET
    (other-window 1)))

(global-set-key (kbd "C-|") 'ensure-two-vertical-windows)
#+end_src
** Obtaining Values of ~#+KEYWORD~ Annotations
Org-mode settings are, for the most part, in the form ~#+KEYWORD: VALUE~. Of notable interest
are the ~TITLE~ and ~NAME~ keywords. We use the following ~org-keywords~ function to obtain
the values of arbitrary ~#+THIS : THAT~ pairs, which may not necessarily be supported by native
Org-mode --we do so for the case, for example, of the ~CATEGORIES~ and ~IMAGE~ tags associated with an article.

#+begin_src emacs-lisp
;; Src: http://kitchingroup.cheme.cmu.edu/blog/2013/05/05/Getting-keyword-options-in-org-files/
(defun org-keywords ()
  "Parse the buffer and return a cons list of (property . value) from lines like: #+PROPERTY: value"
  (org-element-map (org-element-parse-buffer 'element) 'keyword
                   (lambda (keyword) (cons (org-element-property :key keyword)
                                           (org-element-property :value keyword)))))

(defun org-keyword (KEYWORD)
  "Get the value of a KEYWORD in the form of #+KEYWORD: value"
  (cdr (assoc KEYWORD (org-keywords))))
#+end_src

Note that capitalisation in a ‚Äù#+KeyWord‚Äù is irrelevant.

See [[https://orgmode.org/manual/Org-syntax.html][here]] on how to see the abstract syntax tree of an org file
and how to manipulate it.

** Publishing articles to my personal blog
I try to [[https://alhassy.github.io/][blog]] occasionally, so here's a helpful function to quickly
publish the current article to my blog.
#+begin_src emacs-lisp
(define-key global-map "\C-cb" 'my/publish-to-blog)

(cl-defun my/publish-to-blog (&optional (draft nil) (local nil))
  "
  Using ‚ÄòAlBasmala‚Äô setup to publish current article to my blog.
  Details of AlBasmala can be found here:
  https://alhassy.github.io/AlBasmala/

  Locally: ~/alhassy.github.io/content/AlBasmala.org

  A ‚Äòdraft‚Äô will be produced in about ~7 seconds, but does not re-produce
  a PDF and the article has a draft marker near the top. Otherwise,
  it will generally take ~30 seconds due to PDF production, which is normal.
  The default is not a draft and it takes ~20 seconds for the live
  github.io page to update.

  The ‚Äòlocal‚Äô optiona indicates whether the resulting article should be
  viewed using the local server or the live webpage. Live page is default.

  When ‚Äòdraft‚Äô and ‚Äòlocal‚Äô are both set, the resulting page may momentarily
  show a page-not-found error, simply refresh.
  "

  (load-file "~/alhassy.github.io/content/AlBasmala.el")

  ;; --MOVE ME TO ALBASMALA--
  ;; Sometimes the file I'm working with is not a .org file, so:
  (setq file.org (buffer-name))

  (preview-article :draft draft)
  (unless draft (publish))
  (let ((server (if local "http://localhost:4000/" "https://alhassy.github.io/")))
    (async-shell-command (concat "open " server NAME "/") "*blog-post-in-browser*"))
)
#+end_src

* Conclusion ---Why Configuration Files Should be Literate
A configuration file sets up various features for a tool ---and serves as an
essential learning point.  In order to remember them, what they do, and possibly
where you learned about them ---which may include additional resources--- it is
pertinent to document such facts. Benefits of documentating features include:
- A list of the features with human readable names! ---In case you forget what you invested time on!
- Personal documentation! ---Reduce wasting time Googling things that you knew in the past!
- Convincing Need
  - Making notes with decriptive text, as suggested below,
    will make it clear whether you actually need the feature
    or ‚Äújust threw it becuase it looks cool‚Äù ---which leads to ‚Äòinit bankruptcy‚Äô.

    Moreover, actually documenting a feature may make it more to recall
    that you have the feature and have notes for it.

#+begin_quote
Programs are meant to be read by humans and only incidentally for computers to
execute. ---Donald Knuth
#+end_quote

Alongside a feature's installation, I've tried to provide the following:
- /Why/ would I want this? Motivation!
  - Example scenerios and use-cases.
- /How/ do I actually use it? Super terse usage details to ‚Äúget going‚Äù!
- /Where/ is the offical documentation page, or repository? Discovarability!
- Comparisions: Are there other similar features, builtin or otherwise? How do they compare?
  Why have I decided for this one instead of another one?
- Additional comments and reminders related to the feature.
  - E.g., why the feature is now disabled, ‚Äòcommented out‚Äô, when
    before it was useful.

#+begin_quote
Programs without documentation have little value; it's like a claim without evidence! ---Me
#+end_quote

Here are some benefits of having a tool's configurations written literately
as an Org-mode file, then tangeling as appropriate.

- Modularity! ---or *‚ÄúIn Praise of the Monolith‚Äù*

  It may not be feasible, or practical, to split a tool's configuration file
  into multiple file hierarchy. Yet, with Org-mode we may reify the hierarchical
  structure as ‚Äòsections‚Äô and have the resulting configuration read more like
  a novel, easily folding and navigating, between sections.

  - Section headers provide organisation and they're collapsable.

  Even if you can make multiple files, using one monolithic file allows:

  - Really easy to quickly /re-organise/ code!
    - Use ~w~ to move content almost instanteously!
    - In contrast, it's harder to review an entire project, when it's in pieces.
  - Many files requires coming up with descriptive file names; instead
    prefer descriptive org headings ^_^
  - Easily navigatable hierarchy with a nested directory/org-heading structure.
    - Have headings with an introducttory paragraph that explains the
      kind of features being considered ---or, lazily, look at the outlined view
      of subheadings to see what's there.
  - Easy search & review of features since they're in one file.
    - Multiple files makes it harder to remember which features live where.
  - One file is easy to distribute & share!

  Many small files are great for collobaration ---there'll likely be less merge
  conflicts. However, configuration files are usually a one-person project.

- Toggle feature selection without altering any code!

  With a single ~#~ key press, we can comment out a section, thereby disabling the
  features it provides. The features are neither deleted nor forgotten, but we
  can experiment with having them there or not /without/ altering any code!
  Alternatively, one mays use the ~:noexport:~ tag on a section header.

  In contrast, an illiterate setup would have us commenting out large chunks of
  code, which is not as easy to manage.

- Really easy to delete content!

  After a while, I come back and realise I've implemented something silly or
  that is available via some external package, I can quickly delete it.

- Can quickly export to different mediums!

  If you want to share your configuration with others, then an HTML rendition
  with a table of contents and text sprinkled everywhere is more likely to
  attract onlookers since they can easily jump to the sections they're interested in.

- Easily digestible chunks of code!

  With a literate approach, one is empowered to have short source blocks; e.g.,
  not exceeding 30 lines ---read more [[https://dzone.com/articles/rule-30-%E2%80%93-when-method-class-or][here]].  This is more likely to ensure
  (possibly by extracting code into its own functions): The listing fits on one
  screen, avoiding deeply nested control structures, non-repeating common
  logical patterns, increased confidence that the implementation meets the
  stated purpose.

The only reason I would use multiple files or raw code for setting up a tool
would be if I did not have a literate programming environment; i.e., Org-mode.

-----

Emacs   is   fun ^_^

Bye!

-----

![Image-Being-replaced-at-the-office](https://i.redd.it/g6yi40gbivv31.jpg)
